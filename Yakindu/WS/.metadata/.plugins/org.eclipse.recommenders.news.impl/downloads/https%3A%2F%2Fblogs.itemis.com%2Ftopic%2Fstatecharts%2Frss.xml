<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" version="2.0">
  <channel>
    <title>itemis Blog AMP</title>
    <link>https://blogs.itemis.com</link>
    <description>Der Blog der itemis AG: Softwareentwicklung, Usability Engineering, Xtext, Scrum und vieles mehr</description>
    <language>en-us</language>
    <pubDate>Wed, 15 Nov 2017 15:10:11 GMT</pubDate>
    <dc:date>2017-11-15T15:10:11Z</dc:date>
    <dc:language>en-us</dc:language>
    <item>
      <title>Interactive 3D Visualization and Simulation with State Machines</title>
      <link>https://blogs.itemis.com/en/interactive-3d-visualization-and-simulation-with-state-machines</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/interactive-3d-visualization-and-simulation-with-state-machines" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/cars-driving.png?t=1510753614328" alt="cars-driving.png" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;&lt;br&gt;The simulation of behavior models, for instance using YAKINDU Statechart Tools, is an important feature for evolutionary, model-based software development. Imagine that you can see the simulation of the behavior model side-by-side with the behavior of the system at the same time. How would it be if you could interactively change the behavior model, properties of the system or the environment of the system during simulations to explore different solutions?&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="background-color: transparent;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/itemis-yakindu-labs_72dpi.jpg?t=1510753614328&amp;amp;width=724&amp;amp;height=344&amp;amp;name=itemis-yakindu-labs_72dpi.jpg" alt="itemis-yakindu-labs_72dpi.jpg" width="724" height="344"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;&lt;br&gt;The simulation of behavior models, for instance using YAKINDU Statechart Tools, is an important feature for evolutionary, model-based software development. Imagine that you can see the simulation of the behavior model side-by-side with the behavior of the system at the same time. How would it be if you could interactively change the behavior model, properties of the system or the environment of the system during simulations to explore different solutions?&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;In the following video, you see what I have prototypically built to get a feeling for such an interactive 3D visualization and simulation environment. I used &lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools (SCT)&lt;/a&gt; for simulating the system behavior using state machines, which you see on the right side of the video.&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;br&gt;For physics simulation and visualization of the system in its environment, I used the &lt;a href="https://unity3d.com/"&gt;Unity game engine&lt;/a&gt;, which you see on the left side. The data of both tools is synchronized to achieve a co-simulation of the tools.&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt;
&lt;div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;"&gt;
 &lt;div class="wistia_responsive_wrapper" style="height:100%;left:0;position:absolute;top:0;width:100%;"&gt;
  &lt;span class="wistia_embed wistia_async_d8dbqm4wyy  videoFoam=true" style="display:inline-block;height:100%;width:100%"&gt;undefined&lt;/span&gt;
 &lt;/div&gt;
&lt;/div&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;br&gt;Why Interactive 3D Visualization and Simulation?&lt;/h2&gt; 
&lt;p&gt;Before we are going to have a closer look at my proof of concept for an interactive 3D visualization and simulation using YAKINDU Statechart Tools and the Unity game engine, we are first discussing potential benefits of simulation, visualization, and interactivity.&lt;/p&gt; 
&lt;h3&gt;&lt;br&gt;What are potential benefits of &lt;strong&gt;simulation&lt;/strong&gt;?&lt;/h3&gt; 
&lt;p&gt;Simulations allow developers to test their solutions early, for instance, by overcoming missing components and missing prototypes. There are specialized simulation tools for a variety of requirements ranging from tools for physical simulations to tools for simulating the output of pins of a chip. In addition to the system itself, the system's environment can also be simulated - including rarely occurring and unusual situations. For an early feedback, simulation must not be perfectly accurate. It is enough if the approximations, which are used for the simulations, are sufficiently accurate with respect to the functional and non-functional requirements of the system. Early and frequent feedback about the validity and quality of a solution is essential to continuously develop in the right direction. By thus avoiding big changes in later phases of system development, simulations can help to reduce system development costs and time-to-market.&lt;/p&gt; 
&lt;h3&gt;&lt;br&gt;What are potential benefits of &lt;strong&gt;visualization&lt;/strong&gt;?&lt;/h3&gt; 
&lt;p&gt;Data visualizations of system behavior over time generally give a quick and easy to grasp overview of the quality of solutions. After all, a picture is worth a thousand words. 2D/3D Visualizations of system behavior within its environment make solution exploration even more tangible for developers. Moreover, non-technical stakeholders can much better assess if the system behavior meets their requirements, when they can actually see the system behavior compared to when they receive indirect feedback based on abstract tests or data. Different scenarios can be visualized to clarify questions and evaluate possible solutions together with developers. Consequently, non-technical stakeholders are more likely to contribute good feedback for further development. One big advantage of system behavior visualization is thus the reduction of possible misinterpretations and misunderstandings, which are caused by assumptions to cognitively map indirect feedback, such as abstract data, into system behavior. When visualization is used together with simulations, flaws, which otherwise might only be determined when tests with real prototypes are conducted, might be found considerable earlier. As a result, visualization can also help to reduce system development costs and time-to-market.&lt;/p&gt; 
&lt;h3&gt;&lt;br&gt;What are potential benefits of &lt;strong&gt;interactivity&lt;/strong&gt;?&lt;/h3&gt; 
&lt;p&gt;Interactive changes of behavior models, simulation parameters and system environments during simulations facilitate an explorative solution development process and solution tuning. Developers do not have to wait for changes to take effect, for instance due to the compilation process and restart of simulations. Instead, developers instantly see how the system behavior changes based on their modifications. An iterative, model-driven development process can thus be potentially performed more efficiently using interactive changes.&lt;/p&gt; 
&lt;h2&gt;Car Distance Keeper System&lt;/h2&gt; 
&lt;p&gt;&lt;br&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/cars-driving.png?t=1510753614328&amp;amp;width=724&amp;amp;height=345&amp;amp;name=cars-driving.png" alt="cars-driving.png" width="724" height="345"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;br&gt;For the proof of concept of an interactive 3D visualization and simulation, we are building a car distance keeper system. As depicted in the image above, there are two cars that will be driving along a racetrack. The back car is following the front car in a defined distance. To provide a pleasant driving experience for the car occupants, the distance keeper system must smoothly accelerate and decelerate. We can expect a trade-off between acceleration change smoothness and tolerance concerning the distance to the front car, which we need to consider for collision avoidance.&lt;/p&gt; 
&lt;p&gt;Instead of controlling the front car using keyboard input, we use a script to drive the car. The script will automatically control steering and acceleration/deceleration. The front car thus follows a track, which is defined by several waypoints (see image below).&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/topdown-small.png?t=1510753614328&amp;amp;width=724&amp;amp;height=704&amp;amp;name=topdown-small.png" alt="topdown-small.png" width="724" height="704"&gt; 
&lt;h2&gt;&lt;br&gt;Behavior Modelling and Simulation&lt;/h2&gt; 
&lt;p&gt;We are using the YAKINDU Statechart Tools to model and simulate the behavior of the car distance keeper system. You can find more information on &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-1"&gt;how to use state machines for your modelling&lt;/a&gt; and &lt;a href="/en/how-to-simulate-a-statechart-model"&gt;how to simulate a statechart model&lt;/a&gt; with YAKINDU Statechart Tools in our blog. The following listing shows the Car interface, which defines all required values for our model:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;@CycleBased(15)
interface Car:
    // Desired distance to front car
    var readonly targetDistance: real = 10.0
    // Current distance to front car
    var distance : real = targetDistance
    // Current acceleration or deceleration
    // (-1 maximum deceleration to +1 maximum acceleration)
    var acceleration : real = 0.0
    // Smoothing factor for acceleration
    var readonly accelerationSensitivity : real = 0.25
    // Smoothing factor for deceleration
    var readonly brakeSensitivity : real = 0.5

    // Angle between back car heading and direct connection
    // line between the back and front car
    var targetAngle : real = 0.0
    // Current steering angle
    // (-1 maximum steering to the left to
    //  +1 maximum steering to the right)
    var steering : real = 0.0
    // Smoothing factor for steering
    var readonly steerSensitivity : real = 0.05&lt;/pre&gt; 
&lt;p&gt;&lt;br&gt;Please note that &lt;code&gt;readonly&lt;/code&gt; means that the variables must not be changed in the state machine, but it is possible to change the values during simulation. Therefore, &lt;code&gt;readonly&lt;/code&gt; acts as a safeguard without restricting our possibilities for interactive changes during simulation.&lt;/p&gt; 
&lt;h3&gt;&lt;br&gt;Acceleration Behavior Model&lt;/h3&gt; 
&lt;p&gt;Now that the &lt;code&gt;Car&lt;/code&gt; interface is defined, let's model the acceleration behavior. We want a simple model consisting of three states:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="background-color: transparent;"&gt;&lt;strong&gt;Brake&lt;/strong&gt;: Whenever the current &lt;/span&gt;&lt;code style="background-color: transparent; font-size: 16px;"&gt;distance&lt;/code&gt;&lt;span style="background-color: transparent;"&gt; to the front car is smaller than the &lt;/span&gt;&lt;code style="background-color: transparent; font-size: 16px;"&gt;targetDistance&lt;/code&gt;&lt;span style="background-color: transparent;"&gt;, the system needs to brake the car.&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="background-color: transparent;"&gt;&lt;strong&gt;Hold&lt;/strong&gt;: Whenever the current &lt;code&gt;distance&lt;/code&gt; to the front car equals the &lt;code&gt;targetDistance&lt;/code&gt;, the system needs to hold the current velocity of the car.&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="background-color: transparent;"&gt;&lt;strong&gt;Accelerate&lt;/strong&gt;: Whenever the current &lt;code&gt;distance&lt;/code&gt; to the front car is greater than the &lt;code&gt;targetDistance&lt;/code&gt;, the system needs to accelerate the car.&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;The &lt;code&gt;acceleration&lt;/code&gt; magnitude is based on the deviation of the current &lt;code&gt;distance&lt;/code&gt; from the &lt;code&gt;targetDistance&lt;/code&gt;, which is multiplied with the corresponding smoothing factors &lt;code&gt;brakeSensitivity&lt;/code&gt; and &lt;code&gt;accelerationSensitivity&lt;/code&gt;. This model is of course far too simplistic for a real system, such as an Adaptive Cruise Control (ACC), but it is sufficient for illustration purposes in the context of this blog post. Here is an image of the final acceleration behavior model:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/acceleration-model.png?t=1510753614328&amp;amp;width=724&amp;amp;height=325&amp;amp;name=acceleration-model.png" alt="acceleration-model.png" width="724" height="325"&gt; 
&lt;h3&gt;&lt;br&gt;Steering Behavior Model&lt;/h3&gt; 
&lt;p&gt;Next, we need to model the car steering behavior. One simple way to achieve that the back car is following the front car is to align the tires of the back car with the direction towards the front car (i.e. according to the &lt;code&gt;targetAngle&lt;/code&gt;). As the movement range of car tires is limited and we want to avoid a shaky driving experience, we use the &lt;code&gt;steerSensitivity&lt;/code&gt; smoothing factor. Analogous to the acceleration model, we are using three states for the steering behavior model:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;strong style="background-color: transparent;"&gt;Left&lt;/strong&gt;&lt;span style="background-color: transparent;"&gt;: Whenever the front car is to the left (i.e. &lt;/span&gt;&lt;code style="background-color: transparent; font-size: 16px;"&gt;targetAngle&lt;/code&gt;&lt;span style="background-color: transparent;"&gt; &amp;lt; 0), the system needs to steer the car to the left.&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="background-color: transparent;"&gt;Straight&lt;/strong&gt;&lt;span style="background-color: transparent;"&gt;: Whenever the front car is directly in front (i.e. &lt;/span&gt;&lt;code style="background-color: transparent; font-size: 16px;"&gt;targetAngle&lt;/code&gt;&lt;span style="background-color: transparent;"&gt; = 0), the system needs to keep the car straight.&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;strong style="background-color: transparent;"&gt;Right&lt;/strong&gt;&lt;span style="background-color: transparent;"&gt;: Whenever the front car is to the right (i.e. &lt;/span&gt;&lt;code style="background-color: transparent; font-size: 16px;"&gt;targetAngle&lt;/code&gt;&lt;span style="background-color: transparent;"&gt; &amp;gt; 0), the system needs to steer the car to the right.&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Yes, again this model is too simplistic for a real system and you could achieve the same behavior with one state instead of three. However, for visualization purposes it is better to have three logical states so that the active model state indicates the steering direction. An illustration of the final steering behavior model is shown in the following image:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/steering-model.png?t=1510753614328&amp;amp;width=724&amp;amp;height=226&amp;amp;name=steering-model.png" alt="steering-model.png" width="724" height="226"&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;Although we can now simulate both behavior models using YAKINDU Statechart Tools, we would need to manually enter values for the current &lt;code&gt;distance&lt;/code&gt; to the front car as well as the &lt;code&gt;targetAngle&lt;/code&gt; towards the front car. That would not be a very dynamic simulation experience. To create a dynamic simulation, we need to simulate the driving physics and to visualize the car while it is driving.&lt;/p&gt; 
&lt;h2&gt;Physics Simulation and Visualization&lt;/h2&gt; 
&lt;p&gt;The &lt;a href="https://unity3d.com/"&gt;Unity game engine&lt;/a&gt; with its standard assets example project contains everything that we need. It includes a 3D scene consisting of a car on a racetrack. The car is controlled by a script to follow the racetrack based on waypoints, as shown in the "&lt;a href="#car-distance-keeper-system"&gt;Car Distance Keeper System&lt;/a&gt;" section above. Moreover, there is a &lt;code&gt;CarController&lt;/code&gt; script, which provides simple driving physics together with the physics engine that is used by Unity. We just need to add a second car from the standard assets.&lt;/p&gt; 
&lt;p&gt;Now we have, on the one hand, a simulation of the driving physics together with a 3D visualization of the car within its environment. On the other hand, we have the simulation of our acceleration and steering behavior for the back car. The only problem is that both simulations are performed by different tools and thus totally isolated from each other. Consequently, the next key challenge is to let both simulation tools work together.&lt;/p&gt; 
&lt;h2&gt;Co-Simulation&lt;/h2&gt; 
&lt;p&gt;For the co-simulation using both tools, we need to constantly exchange the simulation data. One possibility is to use the YAKINDU Communication Protocol (YaCoP), which can be made available through a plugin for the YAKINDU Statechart Tools. Currently, the YaCoP plugin is not included in the YAKINDU Statechart Tools. If you want to get YaCoP to built this proof of concept or for experimentation, &lt;a href="https://info.itemis.com/contact"&gt;please contact us&lt;/a&gt;. YaCoP sends simple messages over a TCP/IP socket connection. The YaCoP message format consists of three comma-separated values: (1) a # placeholder, (2) the variable name, and (3) the variable value. For instance, when the &lt;code&gt;Car.acceleration&lt;/code&gt; value was changed to &lt;code&gt;0.12345&lt;/code&gt; in the acceleration behavior model simulation, the following message is send over the socket connection:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;#,Car.acceleration,0.12345&lt;/pre&gt; 
&lt;p&gt;&lt;br&gt;If this message would be received instead, the YaCoP plugin would set the value of the &lt;code&gt;Car.acceleration&lt;/code&gt; variable of the acceleration behavior model simulation to &lt;code&gt;0.12345&lt;/code&gt;.&lt;/p&gt; 
&lt;h3&gt;&lt;br&gt;Data Binding in Unity&lt;/h3&gt; 
&lt;p&gt;All that is left is to implement the data binding on the Unity side. The &lt;code&gt;CarAIController&lt;/code&gt; script acts as our basis for a data binding script in C# and is adapted as follows:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;pre class="prettyprint" style="max-height: 450px;"&gt;using System;
using System.Net.Sockets;
using UnityEngine;

namespace UnityStandardAssets.Vehicles.Car
{
    [RequireComponent(typeof (CarController))]
    public class CarSimulationControl : MonoBehaviour
    {
        [SerializeField] private Transform m_FrontCar;

        [SerializeField] private float m_SteerSensitivity = 0.05f;

        [SerializeField] private string m_YacopIp = "127.0.0.1";
        [SerializeField] private int m_YacopPort = 12345;

        private CarController m_Car;

        private TcpClient m_YacopClient;
        private NetworkStream m_YacopStream;

        private float m_Acceleration = 0.0f;
        private float m_Steering = 0.0f;

        private void Awake()
        {
            m_Car = GetComponent();
        }

        // Establish TCP/IP socket connection to the YaCoP plugin on start
        private void Start()
        {
            m_YacopClient = new TcpClient(m_YacopIp, m_YacopPort);
            m_YacopStream = m_YacopClient.GetStream();
        }

        // Close TCP/IP socket connection to the YaCoP plugin on destroy
        private void OnDestroy()
        {
            m_YacopStream.Close();
            m_YacopClient.Close();
        }

        // Process all incoming YaCoP messages to update acceleration and steering
        private void ProcessYacopStreamData()
        {
            while (m_YacopStream.DataAvailable)
            {
                byte[] buffer = new byte[1024];
                int bytes = m_YacopStream.Read(buffer, 0, buffer.Length);
                string data = System.Text.Encoding.UTF8.GetString(buffer, 0, bytes);
                foreach (string message in data.Split('\n'))
                {
                    string[] fields = message.Split(',');

                    if (fields.Length &amp;lt; 3)
                        continue;

                    string name = fields[1];
                    string value = fields[2];

                    if (name == "Car.acceleration")
                    {
                        m_Acceleration = ParseFloat(value);
                    }
                    else if (name == "Car.steering")
                    {
                        m_Steering = ParseFloat(value);
                    }
                }
            }
        }

        private float ParseFloat(string value)
        {
            try
            {
                return float.Parse(value);
            } catch (FormatException e)
            {
                return 0;
            }			
        }

        // Send YaCoP message to update given value in behavior model simulation
        private void UpdateSimulationValue(string name, string value)
        {
            byte[] yacopMessage = System.Text.Encoding.UTF8.GetBytes("#," + name + "," + value + "\n");
            m_YacopStream.Write(yacopMessage, 0, yacopMessage.Length);
        }

        private void UpdateSimulationValue(string name, float value)
        {
            UpdateSimulationValue(name, value.ToString());
        }

        private void FixedUpdate()
        {
            // Read data from behavior model simulation
            ProcessYacopStreamData();
			
            // Clamp steering and adjust sign based on forward/backward movement
            float steer = Mathf.Clamp(m_Steering, -1, 1) * Mathf.Sign(m_Car.CurrentSpeed);
            // Clamp acceleration
            float accel = Mathf.Clamp(m_Acceleration, -1, 1);

            // Use car controller to move the car based on steering and acceleration
            m_Car.Move(steer, accel, accel, 0f);

            // Calculate distance to front car
            Vector3 offset = m_FrontCar.position - transform.position;
            float distance = offset.magnitude;
            // Calculate local angle towards front car
            Vector3 localTarget = transform.InverseTransformPoint(m_FrontCar.position);
            float targetAngle = Mathf.Atan2(localTarget.x, localTarget.z) * Mathf.Rad2Deg;

            // Update behavior model simulation data
            UpdateSimulationValue("Car.distance", distance);
            UpdateSimulationValue("Car.targetAngle", targetAngle);
            UpdateSimulationValue("Car.steerSensitivity", m_SteerSensitivity);
        }
    }
}&lt;/pre&gt; 
&lt;p&gt;&lt;br&gt;The &lt;code&gt;FixedUpdate&lt;/code&gt; callback handles the three main tasks of the controller. First, all incoming YaCoP messages are processed to update the &lt;code&gt;m_Acceleration&lt;/code&gt; and &lt;code&gt;m_Steering&lt;/code&gt; variables of the Unity script with respect to the running behavior model simulation. Second, the car controller component is used to move the car based on the updated steering and acceleration parameters. Third, the &lt;code&gt;distance&lt;/code&gt; towards the front car as well as the &lt;code&gt;targetAngle&lt;/code&gt; towards the front car are determined based on the previous physics update and then sent together with the &lt;code&gt;m_SteerSensitivity&lt;/code&gt; over the YaCoP socket stream to update the behavior model simulation state.&lt;/p&gt; 
&lt;h3&gt;&lt;br&gt;Starting the Co-Simulation&lt;/h3&gt; 
&lt;p&gt;Finally, we need to ensure the right configuration for the YAKINU Statechart Tool simulation. In the run configurations, make sure that the YAKINDU YaCoP Launcher is used and the YaCoP port is set to 12345 (which is the default setting).&lt;/p&gt; 
&lt;p&gt;Let's see the interactive 3D visualization and co-simulation of the car distance keeper system in action. How does it compare to what you have imagined at the beginning of the blog post?&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt;
&lt;div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;"&gt;
 &lt;div class="wistia_responsive_wrapper" style="height:100%;left:0;position:absolute;top:0;width:100%;"&gt;
  &lt;span class="wistia_embed wistia_async_fqvf2fvyx8  videoFoam=true" style="display:inline-block;height:100%;width:100%"&gt;undefined&lt;/span&gt;
 &lt;/div&gt;
&lt;/div&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;br&gt;Interactive Changes&lt;/h2&gt; 
&lt;p&gt;Both Unity and YAKINDU Statechart Tools support interactive parameter changes during simulations. So once the co-simulation is in place, interactive changes can be applied to all bound simulation parameters without any extra effort. Let's start by playing around with the steering sensitivity on the Unity side:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt;
&lt;div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;"&gt;
 &lt;div class="wistia_responsive_wrapper" style="height:100%;left:0;position:absolute;top:0;width:100%;"&gt;
  &lt;span class="wistia_embed wistia_async_vrygm7093i  videoFoam=true" style="display:inline-block;height:100%;width:100%"&gt;undefined&lt;/span&gt;
 &lt;/div&gt;
&lt;/div&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;&lt;br&gt;Now, let's play with the distance to the front car on the YAKINDU Statechart Tools side:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;p&gt; &lt;/p&gt;
&lt;div class="wistia_responsive_padding" style="padding:56.25% 0 0 0;position:relative;"&gt;
 &lt;div class="wistia_responsive_wrapper" style="height:100%;left:0;position:absolute;top:0;width:100%;"&gt;
  &lt;span class="wistia_embed wistia_async_pr5sy35swv  videoFoam=true" style="display:inline-block;height:100%;width:100%"&gt;undefined&lt;/span&gt;
 &lt;/div&gt;
&lt;/div&gt; 
&lt;p&gt;&lt;/p&gt; 
&lt;p&gt;&lt;br&gt;Interactively changing the model parameters helps to get a sense for suitable parameter ranges. At a certain time, however, you will need to ensure that the model parameters fulfil all relevant system requirements.&lt;/p&gt; 
&lt;h2&gt;Model Parameter Tuning&lt;/h2&gt; 
&lt;p&gt;In this section, we want to tune the accelerationSensitivity parameter to fulfil the following two requirements for the car distance keeper system:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;Back car needs to follow front car in a defined distance ± 5m&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;Driving experience must be pleasant for car occupants (i.e. low acceleration variation and avoiding switches between full throttle and braking)&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;The defined distance between the cars is 10m and we set the brakeSensitivity to 0.5. If conditions must be checked over a longer period of time, it can be helpful to look at overview graphs that aggregate the data. Therefore, both distance and acceleration is recorded during two rounds around the racetrack. We are only interested in the situation where the cars are driving, so we remove the first round with the start from a standing position. This procedure is repeated for the following accelerationSensitivity values: 0.05, 0.1, 0.15, 0.2, 0.25, 0.3. By interactively playing with sensitivity, it became clear that the car is already abruptly switching between full throttle and braking at a value of 0.3, so we do not have to check higher values.&lt;/p&gt; 
&lt;p&gt;Here are the plots for the distance to the front car over time:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/plats-distance.png?t=1510753614328&amp;amp;width=724&amp;amp;height=470&amp;amp;name=plats-distance.png" alt="plats-distance.png" width="724" height="470"&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;Up until a sensitivity of 0.2, the actual distance to the front car gets smaller. For higher sensitivities, there are some ripples around the 60-80 seconds' area, which again increases the distance. Let's aggregate the data in a boxplot to have a better overview, which sensitivity values fulfil the distance requirement:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/distance-boxplot.png?t=1510753614328&amp;amp;width=724&amp;amp;height=470&amp;amp;name=distance-boxplot.png" alt="distance-boxplot.png" width="724" height="470"&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;From the boxplot, it is clear that the sensitivities 0.15 and 0.2 are fulfilling the distance requirement 10±5m. For a sensitivity of 0.2, the actual distance to the front car is closer to the defined distance and the distance variation is lower. To decide between the two, we have a look at the acceleration values over time:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/accelaration.png?t=1510753614328&amp;amp;width=724&amp;amp;height=470&amp;amp;name=accelaration.png" alt="accelaration.png" width="724" height="470"&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;In the case of a sensitivity of 0.2, there seems to be stronger acceleration changes. Still, the car is never driving with full throttle. Let's again aggregate the data in a boxplot to have a better overview:&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/accelaration-boxplot.png?t=1510753614328&amp;amp;width=724&amp;amp;height=470&amp;amp;name=accelaration-boxplot.png" alt="accelaration-boxplot.png" width="724" height="470"&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;For a sensitivity of 0.15, the brake is actually never used to control the car, whereas it is used in the 0.2 case. Moreover, the acceleration variation as well as the range between minimum and maximum is higher for the sensitivity of 0.2 case. What is better probably depends on the individual taste of a person. I'll leave it up to you to decide if you prefer a more comfortable or a sportier driving experience or even investigate some further intermediary sensitivities.&lt;/p&gt; 
&lt;h2&gt;Conclusions&lt;/h2&gt; 
&lt;p&gt;In this blog post I started with discussing some potential benefits of using simulations, visualizations and interactivity during system development. I showed how to create an interactive 3D visualization and simulation for a car distance keeper system using YAKINDU Statechart Tools and the Unity game engine. The ability to interactively change parameters and receiving a direct feedback facilitates an explorative and iterative development process. Finally, I outlined one possible way to use simulation data for model parameter tuning.&lt;/p&gt; 
&lt;p&gt;What if you want to use another simulation tool instead of Unity? As long as you can extend the simulation tool with a TCP/IP socket communication to exchange simulation data via YaCoP, you can combine any simulation tool with YAKINDU Statechart Tools. It is also not necessary to visualize the system, so just leave it out if you do not need it.&lt;/p&gt; 
&lt;p&gt;What's next? We are currently working on co-simulation features. Our plans are, among others, to investigate how co-simulation can be performed with a variety of simulation tools. For instance, standards such as the Functional Mock-Up Interface (FMI) provide tool independent means for co-simulation. In this context, it is also important that the data binding and life cycle management for the co-simulation is automatically generated by the simulation tools to avoid manual wiring as done for Unity in this blog post. Another interesting topic is to support varying simulation speeds to allow developers to quickly perform a large amount of simulation runs, for instance in a headless mode. Therefore, it is essential that simulation runs are recorded and can be replayed later to further analyze certain runs.&lt;/p&gt; 
&lt;p&gt;Remember how you have imagined an interactive 3D visualization and simulation environment and then compare it with what I have built and what we have planned. Are we missing something? Do you have further ideas? Do you want to rebuild the presented example yourself? Any kind of feedback is welcome, contact us and let us know what you are thinking!&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=60a0b156-6ae2-4c37-bf79-4293bb3a0d78&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Contact us" src="https://no-cache.hubspot.com/cta/default/761475/60a0b156-6ae2-4c37-bf79-4293bb3a0d78.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Finteractive-3d-visualization-and-simulation-with-state-machines&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <category>YAKINDU Labs</category>
      <pubDate>Wed, 15 Nov 2017 15:10:00 GMT</pubDate>
      <author>bbolte@itemis.de (Benjamin Bolte)</author>
      <guid>https://blogs.itemis.com/en/interactive-3d-visualization-and-simulation-with-state-machines</guid>
      <dc:date>2017-11-15T15:10:00Z</dc:date>
    </item>
    <item>
      <title>Test driven development with YAKINDU Statechart Tools’ SCTUnit</title>
      <link>https://blogs.itemis.com/en/test-driven-development-with-yakindu-statechart-tools-sctunit</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/test-driven-development-with-yakindu-statechart-tools-sctunit" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/Agile/TDD-Refactor-Cycle.png?t=1510753614328" alt="Test driven development with YAKINDU Statechart Tools’ SCTUnit" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Recently we had a discussion about Test Driven Development. Is it really important or just a buzzword. We agreed quickly: it is not a Buzzword. &lt;strong&gt;TDD is a &lt;/strong&gt;&lt;/span&gt;&lt;strong style="background-color: transparent;"&gt;skill&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. You need to acquire it, you need to practice it, you need to &lt;/span&gt;&lt;strong style="background-color: transparent;"&gt;do it&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. &lt;/span&gt;&lt;a href="/en/model-driven-software-development-meets-test-driven-development"&gt;&lt;span&gt;And you can do TDD on statechart models within YAKINDU Statechart Tools&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;&amp;nbsp;– with SCTUnit.&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Recently we had a discussion about Test Driven Development. Is it really important or just a buzzword. We agreed quickly: it is not a Buzzword. &lt;strong&gt;TDD is a &lt;/strong&gt;&lt;/span&gt;&lt;strong style="background-color: transparent;"&gt;skill&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. You need to acquire it, you need to practice it, you need to &lt;/span&gt;&lt;strong style="background-color: transparent;"&gt;do it&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. &lt;/span&gt;&lt;a href="/en/model-driven-software-development-meets-test-driven-development"&gt;&lt;span&gt;And you can do TDD on statechart models within YAKINDU Statechart Tools&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;&amp;nbsp;– with SCTUnit.&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/user-guide/#sctunit_test-driven_statechart_development_with_sctunit"&gt;&lt;span style="font-weight: 400;"&gt;SCTUnit&lt;/span&gt;&lt;/a&gt; &lt;span style="font-weight: 400;"&gt;is part of the current YAKINDU Statechart Tools Standard Edition. &lt;strong&gt;With SCTUnit you can apply TDD within your model driven development process&lt;/strong&gt;. As the following image illustrates usually we start with a failing test, fix the test by coding and refactor. Then the cycle restarts and we write the next Test. With YAKINDU Statechart Tools we write a test for the statechart model, then fix the model and refactor the model. &lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/Agile/TDD-Refactor-Cycle.png?t=1510753614328&amp;amp;width=724&amp;amp;name=TDD-Refactor-Cycle.png" alt="TDD Refactor Cycle" title="TDD Refactor Cycle" width="724" style="width: 724px;"&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;h2&gt;Test driven development wit YAKINDU Statechart Tools' SCTUnit&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Let us practice this skill now for a simple traffic light model. We organize the tests within the regular project. So first we create a project with a folder ‘model’ and a folder ‘test’.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Then we create the first test. Within YAKINDU Statechart Tools this is called “SCT Unit Test Class”. It is a test file similar to a unit test class within other programming languages. The new file is already filled with the most important statements. It looks like this:&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;testclass&amp;nbsp;initialTest&amp;nbsp;for statechart&amp;nbsp;trafficLight {&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;@Test&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;operation&amp;nbsp;test() {&lt;br&gt;&amp;nbsp;&amp;nbsp;&lt;br&gt;&amp;nbsp;enter&lt;br&gt;&lt;br&gt;&amp;nbsp;exit&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&lt;br&gt;}&lt;/pre&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The keyword &lt;/span&gt;&lt;code&gt;testclass&lt;/code&gt; &lt;span style="font-weight: 400;"&gt;introduces a test class, a collection of tests. In this example, it is named &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;trafficLight&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;A test class always refers to a statechart that is under control and is to be tested. This relationship is established by the &lt;/span&gt;&lt;code&gt;for statechart&lt;/code&gt;&lt;span style="font-weight: 400;"&gt; clause. &lt;/span&gt;&lt;/p&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now we create this test:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://info.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/TDD_01_CreateProject.gif?t=1510753614328"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/TDD_01_CreateProject.gif?t=1510753614328&amp;amp;width=724&amp;amp;name=TDD_01_CreateProject.gif" alt="TDD Test-Driven Development - Crate statechart project" width="724" title="TDD Test-Driven Development - Crate statechart project" style="width: 724px;"&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;There is an error marker, so the test fails. This is because there is no statechart named trafficLight. So let us fix this:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://info.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/TDD_02_Test_CreateModel.gif?t=1510753614328"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/TDD_02_Test_CreateModel.gif?t=1510753614328&amp;amp;width=724&amp;amp;name=TDD_02_Test_CreateModel.gif" alt="TDD Test Driven Development – Create statechart model" width="724" title="TDD Test Driven Development – Create statechart model" style="width: 724px;"&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now the test is green again. We do not have much to refactor for now, so we create the next test. What behavior do we want to model? We start with a state &lt;/span&gt;&lt;strong&gt;Red&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. After 1 s it shall switch to &lt;/span&gt;&lt;strong&gt;Yellow &lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;and then to &lt;/span&gt;&lt;strong&gt;Green &lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;and then exit. For now we only model one traffic light cycle. Every statechart needs an &lt;/span&gt;&lt;strong&gt;entry &lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;and an &lt;/span&gt;&lt;strong&gt;exit &lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;state. &lt;/span&gt;&lt;/p&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The test statement will look like the following:&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;enter&lt;br&gt;assert active (trafficLight.main_region.Red)&lt;br&gt;proceed 1 s&lt;br&gt;&lt;br&gt;assert active (trafficLight.main_region.Yellow)&lt;br&gt;proceed 1 s&lt;br&gt;&lt;br&gt;assert active (trafficLight.main_region.Green)&lt;br&gt;exit&lt;/pre&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;You may know assert statements from other unit frameworks. Referring to state machines we assert that a certain state is active or not. First we want the &lt;/span&gt;&lt;strong&gt;Red &lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;state to be active. To identify the Red state we use an absolute path:&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;&amp;lt;nameOfTheState&amp;gt;.&amp;lt;nameOfTheRegion&amp;gt;.&amp;lt;nameOfTheState&amp;gt;&lt;/pre&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The &lt;/span&gt;&lt;code&gt;proceed 1 s &lt;/code&gt;&lt;span style="font-weight: 400;"&gt;instruction orders the state machine to execute the state machine for 1 s. After this one second the Yellow state shall be active and so on. Finally the test leaves the state machine as indicated by the keyword &lt;/span&gt;&lt;strong&gt;exit&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;This test fails; it does not even compile. So we are in the red phase of our TDD cycle. Let’s make it green and enhance the statemachine by two additional states and transitions.&lt;/span&gt;&lt;/p&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;a href="https://info.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/TDD_03_CreateFailingTest.gif?t=1510753614328"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/TDD_03_CreateFailingTest.gif?t=1510753614328&amp;amp;width=724&amp;amp;name=TDD_03_CreateFailingTest.gif" alt="TDD Test Driven Development – Create the Failing Test" width="724" title="TDD Test Driven Development – Create the Failing Test" style="width: 724px;"&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The test compiles. Now let us run it. Similar to Junit or other unit testing frameworks we start it by selecting the test, right click, select &lt;/span&gt;&lt;strong&gt;Run as… SCTUnit&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; test. You will see a view similar to JUnit.&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="https://info.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/TDD_04_RunTest%20(1).gif?t=1510753614328"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/TDD_04_RunTest%20(1).gif?t=1510753614328&amp;amp;width=724&amp;amp;name=TDD_04_RunTest%20(1).gif" alt="TDD Test-Driven Development Running Test with SCTUnit" width="724" title="TDD Test-Driven Development Running Test with SCTUnit" style="width: 724px;"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now we have a running model and a test and we can proceed with further development. Because we have the test(s) we can be sure that the statechart does what it should do. Another benefit is: we save time we used for simulating and testing the correct behavior manually. So try this feature out. It is part of the &lt;/span&gt;&lt;strong&gt;YAKINDU Statechart Tools Standard Edition&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; you can freely use for non-commercial purposes.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;I am interested in your experiences with SCTUnit and YAKINDU Statechart Tools. Please comment or write an e-mail to &lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="mailto:yakindu@itemis.de"&gt;yakindu@itemis.de&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;If you want to try YAKINDU Statechart Tools yourself – just download it!&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Ftest-driven-development-with-yakindu-statechart-tools-sctunit&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <category>english</category>
      <pubDate>Thu, 19 Oct 2017 10:09:00 GMT</pubDate>
      <author>svenja.wendler@itemis.de (Svenja Wendler)</author>
      <guid>https://blogs.itemis.com/en/test-driven-development-with-yakindu-statechart-tools-sctunit</guid>
      <dc:date>2017-10-19T10:09:00Z</dc:date>
    </item>
    <item>
      <title>YAKINDU Statechart Tools October release – new and noteworthy</title>
      <link>https://blogs.itemis.com/en/yakindu-statechart-tools-october-release-new-and-noteworthy</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/yakindu-statechart-tools-october-release-new-and-noteworthy" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/Update-handwritten.jpg?t=1510753614328" alt="Update-handwritten.jpg" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;We released YAKINDU Statechart Tools Standard and Professional Edition version 3.1.0 today! Apart from several bug fixes we added the following main features:&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="background-color: transparent;"&gt;We released YAKINDU Statechart Tools Standard and Professional Edition version 3.1.0 today! Apart from several bug fixes we added the following main features:&lt;/span&gt;&lt;/p&gt;  
&lt;h2&gt;New features&lt;/h2&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Using properties and expressions in generator models&lt;/span&gt;&lt;span style="font-weight: 400;"&gt; (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/325"&gt;&lt;span style="font-weight: 400;"&gt;#325&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Named parameter calls (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1623"&gt;&lt;span style="font-weight: 400;"&gt;#1623&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Option to skip generation of library files&lt;/span&gt; &lt;span style="font-weight: 400;"&gt;&amp;nbsp;(&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1645"&gt;&lt;span style="font-weight: 400;"&gt;#1645&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation"&gt;&lt;span style="font-weight: 400;"&gt;New online documentation&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h2&gt;Using properties and expressions in generator models&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;An generator model may assign values to properties and later use these properties in expressions. The following sample generator model uses the &lt;/span&gt;&lt;strong&gt;var&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; keyword to declare the properties &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;projectName&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;version&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;isBeta&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, and &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;generateTimerServce&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; with their respective types and default values.&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;GeneratorModel for yakindu::java {
    
    //Variables can be overridden from command line interface:
    
    var projectName : string = "light_switch_series"
    var version : string = "1.0"
    var isBeta : boolean = true
    var generateTimerServce : boolean = true

    statechart myStateAutomaton {
    
        feature Outlet {
            targetProject = projectName
            targetFolder = "src-gen/" + version + (isBeta ? "beta" : "")
            libraryTargetFolder = "src"
        }
        
        feature GeneralFeatures {
            TimerService = generateTimerServce
        }
    }
}
&lt;/pre&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The model then uses these values in &lt;/span&gt;&lt;strong&gt;feature&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; clauses by referring to the properties: The values assigned to properties are &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;default&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; values only and can be overridden from the headless code generator like this:&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;scc -m myGenmodel.sct -v version=2.0;isBeta=false&lt;/pre&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The name/value pairs specified by the -v option would override the corresponding default values of the properties in the generator model.This is a very flexible way to tailor the code generator within a headless build.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/hdls_headless_code_generation"&gt;Read more about this feature in our user guide&lt;/a&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;Named parameter calls&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now you can can use named parameters when calling an operation. Consider the following operation declaration:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;operation myOperation(xValue : int, yValue : int) : void&lt;/span&gt;&lt;/i&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;This can be called with name parameters like this:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;myOperation(xValue = 27, yValue = 42)&lt;/span&gt;&lt;/i&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Named parameters make their order irrelevant. The following call is semantically equivalent to the one above:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;myOperation(yValue = 42, xValue = 27)&lt;/span&gt;&lt;/i&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;While an operation call with named parameters is longer than the equivalent call with positional parameters, named parameters are a great means for self-documenting code (especially if the parameter names are more telling than in the example above).&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;Option to skip generation of library files&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The &lt;/span&gt;&lt;strong&gt;Outlet&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; feature now has an option to skip the generation of library files. This is useful to prevent the generation of a new library file when an existing one should be used:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;skipLibraryFiles&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; (Boolean, optional): If you wish to exclude the static files from the code generation, i.e. those that are put into the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;libraryTargetFolder&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, you can set this value to &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;true&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. If the value is &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;false&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; or not specified at all, the files are generated as usual. Currently supported for the Java, C and C++ generators.&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;feature Outlet {
    targetProject = projectName
    targetFolder = "src-gen/"
    libraryTargetFolder = "src"
    skipLibraryFiles = headless ? true : false
}
&lt;/pre&gt; 
&lt;h2&gt;Miscellaneous improvements and bug fixes&lt;/h2&gt; 
&lt;h3&gt;Usability improvements&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Add a checkbox "save automatically" to the save dialog when running a simulation (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1275"&gt;&lt;span style="font-weight: 400;"&gt;#1275&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Perspective switch for “Debug As” (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1646"&gt;&lt;span style="font-weight: 400;"&gt;#1646&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Error markers of subdiagrams are not propagated to parent diagram (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/pull/1288"&gt;&lt;span style="font-weight: 400;"&gt;#1288&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;“Run As” context menu action available in diagram (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1626"&gt;&lt;span style="font-weight: 400;"&gt;#1626&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Implicit imports for active(State) statements (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1294"&gt;&lt;span style="font-weight: 400;"&gt;#1294&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;Code generation improvements&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;“Effective C++” compliant code (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1633"&gt;&lt;span style="font-weight: 400;"&gt;#1633&lt;/span&gt;&lt;/a&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1634"&gt; &lt;span style="font-weight: 400;"&gt;#1634&lt;/span&gt;&lt;/a&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1610"&gt; &lt;span style="font-weight: 400;"&gt;#1610&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Removed unused includes for cycle based state machines (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1650"&gt;&lt;span style="font-weight: 400;"&gt;#1650&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Provide a constant that provides the maximum number of parallel time events of a state machine (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1600"&gt;&lt;span style="font-weight: 400;"&gt;#1600&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;h3&gt;Bug fixes&lt;/h3&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;[Performance] The system still slows down more and more for each successive single-step (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1616"&gt;&lt;span style="font-weight: 400;"&gt;#1616&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Content assist on transitions and states shows implicit variable "period" (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1586"&gt;&lt;span style="font-weight: 400;"&gt;#1586&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Missing validation rule for top-level regions without entry (&lt;/span&gt;&lt;a href="https://github.com/Yakindu/statecharts/issues/1363"&gt;&lt;span style="font-weight: 400;"&gt;#1363&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;)&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fyakindu-statechart-tools-october-release-new-and-noteworthy&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Wed, 04 Oct 2017 14:43:30 GMT</pubDate>
      <author>andreas.muelder@itemis.de (Andreas Mülder)</author>
      <guid>https://blogs.itemis.com/en/yakindu-statechart-tools-october-release-new-and-noteworthy</guid>
      <dc:date>2017-10-04T14:43:30Z</dc:date>
    </item>
    <item>
      <title>How to use state machines for your modeling (Part 5): The State Pattern</title>
      <link>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modeling-part-5-the-state-pattern</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modeling-part-5-the-state-pattern" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/Fensterfront-la%CC%88sst-Licht-rein.jpg?t=1510753614328" alt="How to use state machines for your modeling (Part 5): The State Pattern" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;After we have discovered the implementation of state machines by means of &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-3-the-big-switch-statement"&gt;switch statement&lt;/a&gt; and &lt;a href="/en/how-to-use-state-machines-for-your-modeling-part-4-the-state-machine-as-a-table"&gt;table&lt;/a&gt;, let's take a look at an object-oriented implementation variant: the State pattern. We will then compare the three variants.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;After we have discovered the implementation of state machines by means of &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-3-the-big-switch-statement"&gt;switch statement&lt;/a&gt; and &lt;a href="/en/how-to-use-state-machines-for-your-modeling-part-4-the-state-machine-as-a-table"&gt;table&lt;/a&gt;, let's take a look at an object-oriented implementation variant: the State pattern. We will then compare the three variants.&lt;/p&gt; 
&lt;br&gt; 
&lt;p&gt;The State software design pattern is implemented by Spring Statemachine, Boost Meta Static Machine (MSM) or the Qt State Machine Framework. The State pattern belongs to the group of behavioural design patterns, and encapsulates the state-dependent behavior of an object as seen from the outside. Each state is implemented as a separate class that defines the behaviour of the machine in that state. All state classes are derived from a common interface, so that all states can be treated uniformly.&lt;/p&gt; 
&lt;p&gt;The class diagram of the blind control system is as follows:&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Klassendiagramm-einer-Jalousiesteuerung.png?t=1510753614328&amp;amp;width=724&amp;amp;height=430&amp;amp;name=Klassendiagramm-einer-Jalousiesteuerung.png" alt="Klassendiagramm-einer-Jalousiesteuerung.png" width="724" height="430"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;br&gt;The interface S&lt;i&gt;tate&lt;/i&gt; defines the methods whose behavior is state-dependent. In addition to the methods starting with &lt;i&gt;raise…&lt;/i&gt; to trigger an event, there is the method &lt;i&gt;getName&lt;/i&gt;, which returns the name of the state.&lt;/p&gt; 
&lt;p&gt;The &lt;i&gt;StateMachine&lt;/i&gt; class represents the state machine. In the attribute &lt;i&gt;activeState&lt;/i&gt; it manages the class corresponding to the active state, and thus the state-specific behaviour. The State pattern is similar to the Strategy pattern: a state corresponds to a strategy, i.e. the implementation of a concrete behaviour. However, while the strategy in the Strategy pattern is set from the outside, the states in the State pattern take care of this themselves. In the state pattern, if you like, a "strategy" replaces itself with another – or in the correct nomenclature: a state activates its subsequent state on its own.&lt;/p&gt; 
&lt;p&gt;Let's take a closer look at the example. The client application sends messages to the state machine by calling &lt;i&gt;StateMachine&lt;/i&gt; methods. Let's say the user presses the [↓] key. The client informs the state machine about this action by calling the &lt;i&gt;raiseUserDown&lt;/i&gt; method. The response of the machine depends on the active state:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;In the &lt;strong&gt;Moving up&lt;/strong&gt; state, the machine changes to the &lt;strong&gt;Idle&lt;/strong&gt; state.&lt;/li&gt; 
 &lt;li&gt;In the &lt;strong&gt;Idle&lt;/strong&gt; state, the machine switches to the &lt;strong&gt;Moving down&lt;/strong&gt; state.&lt;/li&gt; 
 &lt;li&gt;In the &lt;strong&gt;Moving down&lt;/strong&gt; state, the automaton ignores the event.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;i&gt;StateMachine&lt;/i&gt; therefore delegates the call to the corresponding method of the active state object. The &lt;i&gt;StateMachine&lt;/i&gt; method &lt;i&gt;raiseUserDown&lt;/i&gt; calls the same-named method of &lt;i&gt;activeState&lt;/i&gt;:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;public void raiseUserDown() {
    activeState.raiseUserDown();
}&lt;/pre&gt; 
&lt;p&gt;What happens next is at the discretion of the state object. If it is an object of class &lt;i&gt;Idle&lt;/i&gt;, a transition to &lt;strong&gt;Moving down&lt;/strong&gt; occurs. This is what &lt;i&gt;raiseUserDown&lt;/i&gt; looks like in &lt;i&gt;Idle&lt;/i&gt;:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;public void raiseUserDown() {
    stateMachine.activateState(new MovingDown(stateMachine));
}&lt;/pre&gt; 
&lt;p&gt;The method activates the new state by passing a corresponding state object to the &lt;i&gt;StateMachine&lt;/i&gt; method &lt;i&gt;activateState&lt;/i&gt;, which assigns it to the &lt;i&gt;activeState&lt;/i&gt; field.&lt;/p&gt; 
&lt;p&gt;If, on the other hand, the machine is in the &lt;strong&gt;Moving down&lt;/strong&gt; state, nothing should be done when &lt;i&gt;raiseUserDown&lt;/i&gt; is called. The &lt;i&gt;MovingDown&lt;/i&gt; class therefore does not implement this method at all. Instead, the &lt;i&gt;raiseUserDown&lt;/i&gt; implementation of superclass &lt;i&gt;AbstractState&lt;/i&gt; is called:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;public void raiseUserDown() {
}&lt;/pre&gt; 
&lt;p&gt;This method does nothing and thus ignores the event – in our case, a meaningful default behaviour for all events for which the particular concrete state class does not implement any behaviour.&lt;/p&gt; 
&lt;h2&gt;Source code of the example application&lt;/h2&gt; 
&lt;p&gt;Let's look at the source code of the blind control system in an implementation based on the State pattern. The state machine consists of six classes, as well as a client class that uses the machine.&lt;/p&gt; 
&lt;p&gt;The interface &lt;i&gt;State&lt;/i&gt; specifies what is a state in the example application:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;

public interface State {

   public void raiseUserUp();
   
   public void raiseUserDown();
   
   public void raisePosSensorUpperPosition();

   public void raisePosSensorLowerPosition();

   public String getName();

}&lt;/pre&gt; 
&lt;p&gt;The &lt;i&gt;AbstractState&lt;/i&gt; abstract class implements the reference to the &lt;i&gt;StateMachine&lt;/i&gt; and the default behaviour for events, ignoring it:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;

abstract public class AbstractState implements State {

   protected StateMachine stateMachine;

   public AbstractState(StateMachine stateMachine) {
       this.stateMachine = stateMachine;
   }

   public void raiseUserUp() {
   }

   public void raiseUserDown() {
   }

   public void raisePosSensorUpperPosition() {
   }

   public void raisePosSensorLowerPosition() {
   }

   abstract public String getName();

}&lt;/pre&gt; 
&lt;p&gt;The classes &lt;i&gt;Idle&lt;/i&gt;, &lt;i&gt;MovingUp&lt;/i&gt; and &lt;i&gt;MovingDown&lt;/i&gt; represent the three concrete states:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;

public class Idle extends AbstractState {

   public Idle(StateMachine stateMachine) {
       super(stateMachine);
   }

   @Override
   public void raiseUserUp() {
       stateMachine.activateState(new MovingUp(stateMachine));
   }

   @Override
   public void raiseUserDown() {
       stateMachine.activateState(new MovingDown(stateMachine));
   }

   @Override
   public String getName() {
       return "Idle";
   }
}
&lt;/pre&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;

public class MovingUp extends AbstractState {

   public MovingUp(StateMachine stateMachine) {
       super(stateMachine);
   }

   @Override
   public void raiseUserDown() {
       stateMachine.activateState(new Idle(stateMachine));
   }

   @Override
   public void raisePosSensorUpperPosition() {
       stateMachine.activateState(new Idle(stateMachine));
   }

   @Override
   public String getName() {
       return "Moving up";
   }
}&lt;/pre&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;


public class MovingDown extends AbstractState {


   public MovingDown(StateMachine stateMachine) {

       super(stateMachine);

   }


   @Override

   public void raiseUserUp() {

       stateMachine.activateState(new Idle(stateMachine));

   }


   @Override

   public void raisePosSensorLowerPosition() {

       stateMachine.activateState(new Idle(stateMachine));

   }


   @Override

   public String getName() {

       return "Moving down";

   }


}&lt;/pre&gt; 
&lt;p&gt;The &lt;i&gt;StateMachine&lt;/i&gt; class is the "face" of the state machine that is shown to the outside:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;


public class StateMachine {


   public StateMachine() {

       activateState(new Idle(this));

   }


   State activeState = null;


   public void activateState(State state) {

       activeState = state;

   }


   public State getActiveState() {

       return activeState;

   }


   public void raiseUserUp() {

       activeState.raiseUserUp();

   }


   public void raiseUserDown() {

       activeState.raiseUserDown();

   }


   public void raisePosSensorUpperPosition() {

       activeState.raisePosSensorUpperPosition();

   }


   public void raisePosSensorLowerPosition() {

       activeState.raisePosSensorLowerPosition();

   }


}&lt;/pre&gt; 
&lt;p&gt;The state machine is used by the application code like this:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;package de.itemis.state_machine.example.state_pattern;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Example {

   public static void main(String[] args) throws IOException {

       StateMachine stateMachine = new StateMachine();
       stateMachine.activateState(new Idle(stateMachine));
       BufferedReader console = new BufferedReader(new InputStreamReader(System.in));

       while (true) {

           System.out.println("Active state: " + stateMachine.getActiveState().getName());
           System.out.print("Please enter event number! ");
           System.out.print("1: User.up, 2: User.down, 3: PosSensor.upperPosition, ");
           System.out.println("4: PosSensor.lowerPosition");
           
           String line = console.readLine();

           int eventNr = -1;

           try {
               eventNr = Integer.parseInt(line);

           } catch (NumberFormatException ex) {
               eventNr = -1;

           }

           switch (eventNr) {

               case 1:
                   stateMachine.raiseUserUp();
                   break;
    
               case 2:
                   stateMachine.raiseUserDown();
                   break;
    
               case 3:
                   stateMachine.raisePosSensorUpperPosition();
                   break;
    
               case 4:
                   stateMachine.raisePosSensorLowerPosition();
                   break;
    
               default:
                   System.out.println("Unknown event number: " + eventNr + ".");
                   break;

           }
       }
   }
}&lt;/pre&gt; 
&lt;p&gt;By the way, an object-oriented programming language is not necessarily required for the State pattern. It can also be implemented with an imperative language such as C as long as the language supports function pointers. The core of the State pattern is that the active state reacts to events and activates another state, if needed.&lt;/p&gt; 
&lt;p&gt;In a C implementation each state is associated with a function (the "state function") that implements the relevant actions. The state machine memorizes the active state by a pointer to its state function. This returns a pointer to the next state or more precisely: to the latter’s state function.&lt;/p&gt; 
&lt;h2&gt;Which implementation approach is best?&lt;/h2&gt; 
&lt;p&gt;For "real" computers such as notebooks, desktops or servers, the differences between implementations do not really matter. The situation is different for embedded devices, which are typically very limited in memory or CPU performance. The clear answer of which implementation is best is – it depends.&lt;/p&gt; 
&lt;p&gt;State machines are very fast. In a state machine with few states and few events, optimization considerations are hardly worthwhile. The situation is different with a large number of states or events. At this point, however, we won’t ponder what exactly a ”large“ number is – 500?, 50,000?, 5 million? –, but look at a few basic considerations only.&lt;/p&gt; 
&lt;p&gt;A large number of states means that:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;The switch statement contains many cases.&lt;/li&gt; 
 &lt;li&gt;The (one-dimensional) state transition table becomes very tall.&lt;/li&gt; 
 &lt;li&gt;The state pattern requires many state classes.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;If the number of events is large, this means that:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Within the individual case clauses in the switch statement there is a lot to do, depending on the respective state.&lt;/li&gt; 
 &lt;li&gt;The state transition table becomes very wide.&lt;/li&gt; 
 &lt;li&gt;In the State pattern the individual state classes are quite extensive, depending on the respective state.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;In all implementation scenarios, the execution time is composed of the following elements:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;Searching for the active state&lt;/li&gt; 
 &lt;li&gt;Searching for a transition based on the event(s)&lt;/li&gt; 
 &lt;li&gt;Activating the subsequent state&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;In addition, guard conditions and actions have their respective execution times. Since these are highly application-specific, however, we will not consider them further here. The activation of the subsequent state consists in each case of a simple assignment: we can ignore its time and memory requirements.&lt;/p&gt; 
&lt;h3&gt;Execution time requirements&lt;/h3&gt; 
&lt;p&gt;To find the active state, the switch statement performs at least one comparison, the situation in which the first case clause of the switch statement is the active state. At worst, the switch statement requires as many comparisons as there are states, i.e. if the last case clause corresponds to the active state. If all states are active equally frequently, the switch statement performs on average &lt;i&gt;z&lt;/i&gt;/2 comparisons, where &lt;i&gt;z&lt;/i&gt; is the number of states. The execution time is thus of the order of magnitude O(&lt;i&gt;z&lt;/i&gt;). This is followed by the analysis of whether specific events are present. This would trigger the corresponding transitions. The execution time for this is – with a similar consideration as for the states – of the order of magnitude O(&lt;i&gt;e&lt;/i&gt;), where &lt;i&gt;e&lt;/i&gt; is the number of event types.&lt;/p&gt; 
&lt;p&gt;The execution time requirement for the lookup operation in a one-dimensional state transition table is also O(&lt;i&gt;z&lt;/i&gt;) + O(&lt;i&gt;e&lt;/i&gt;). The first term describes the row-by-row searching for the active state, the second term represents the search for a given event within the row. If there are several transitions from the active state to different subsequent states, then several rows usually have to be searched. However, this does not change the order of magnitude.&lt;/p&gt; 
&lt;p&gt;The object-oriented approach wins out here, with a time requirement that is independent of the number of states. Since the active state is already present as an object, the time requirement for "searching" the active state is of the order of magnitude O(1). Then there’s the method call corresponding to the event. At first glance this may also look like O(1), but the effort is likely to be conservatively estimated at O(&lt;i&gt;e&lt;/i&gt;), depending on the programming language and its runtime environment.&lt;/p&gt; 
&lt;h3&gt;Memory requirements&lt;/h3&gt; 
&lt;p&gt;Switch statement as well as state transition table must include all combinations of state and event, either in the program code of the switch statement or in the table data. The memory requirement is therefore of the order of magnitude O(&lt;i&gt;z&lt;/i&gt; · &lt;i&gt;e&lt;/i&gt;) in both cases. However, the table always occupies this memory space to its full extent, even if it is sparsely populated. The switch statement, on the other hand, only needs to encode those state/event combinations for which an event leads to a transition. On the other hand, a function pointer in the table occupies only the memory size of an address, which in general should be less than the code that a single state/event combination occupies on average.&lt;/p&gt; 
&lt;p&gt;In the State pattern each state class contains a method for each event that the respective state must take into account. Thus we also have an order of magnitude is also O(&lt;i&gt;z&lt;/i&gt; · &lt;i&gt;e&lt;/i&gt;). As with the switch statement, however, only those event methods have to be coded that should affect something other than the general behaviour implemented in the abstract upper class. Only these methods require space for their program code.&lt;/p&gt; 
&lt;h3&gt;ROM or RAM memory&lt;/h3&gt; 
&lt;p&gt;It is important to consider the devices on which a state machine is to run. Object-oriented languages typically require a large runtime environment and more RAM. This can limit or prevent their use on embedded devices. The more program parts can be fitted into immutable ROM, the better. Executable code, as in the switch statement, falls into this category, as well as hard-coded state transition tables. In an object-oriented implementation of the State pattern you should reuse static state objects, rather than always dynamically creating new objects in RAM.&lt;/p&gt; 
&lt;h3&gt;Debugging capability&lt;/h3&gt; 
&lt;p&gt;It is also important to know how easily a statechart application can be debugged during development. A developer needs to be able to set breakpoints at specific points in the application to halt execution there and continue it step by step, to analyze why the application does not behave as expected. In a state class this is quite simple. Switch statements are also suitable. For tables, the developer can only set breakpoints in the functions to which the function pointers in the table refer. If these pointers are in the wrong cells, however, the analysis is tricky.&lt;/p&gt; 
&lt;h3&gt;Clarity and maintainability&lt;/h3&gt; 
&lt;p&gt;Generally the code of state machines is neither intuitive nor comprehensible. In this respect the State pattern is best, because it avoids a confusing and difficult-to-read switch statement. As long as a state does not have to handle too many different events, it remains manageable. New states require only new state classes; a change in the behaviour is limited to a change in the affected states. This reduces maintenance effort.&lt;/p&gt; 
&lt;p&gt;In the case of automata with few states, on the other hand, the effort of an object-oriented implementation is not necessarily worthwhile, because a switch statement in this case would not be so confusing.&lt;/p&gt; 
&lt;p&gt;If a state machine framework is available and is suitable for the target platform from a resource requirements viewpoint, it should be used: comprehensibility and maintainability can only benefit.&lt;/p&gt; 
&lt;h2&gt;Outlook – Generating source code automatically&lt;/h2&gt; 
&lt;p&gt;All the implementation variants we have discussed suffer from a number of disadvantages in principle:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;No form of implementation can come close to the state diagram in terms of clarity and intelligibility. The more extensive a state machine is, the more unreadable and unmanageable is its representation as program code or state transition table.&lt;/li&gt; 
 &lt;li&gt;The transformation of a state diagram into an implementation is complex and error-prone.&lt;/li&gt; 
 &lt;li&gt;Changes to the statechart mean changes to the implementation. This is again complicated, error-prone and in no way easy to maintain.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;Implementation effort and complexity require tool support, so that a developer ideally only needs to take care of the graphical statechart. In the next part of this series, we will learn how &lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools&lt;/a&gt; is supporting this.&lt;/p&gt; 
&lt;p&gt;To read the whole “How to use state machines for your modelling” series, download our whitepaper for free.&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=11a95e87-0e67-4562-beaa-35526a9e7616&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Download free whitepaper now" src="https://no-cache.hubspot.com/cta/default/761475/11a95e87-0e67-4562-beaa-35526a9e7616.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fhow-to-use-state-machines-for-your-modeling-part-5-the-state-pattern&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Mon, 11 Sep 2017 14:03:00 GMT</pubDate>
      <author>rainer.klute@itemis.de (Rainer Klute)</author>
      <guid>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modeling-part-5-the-state-pattern</guid>
      <dc:date>2017-09-11T14:03:00Z</dc:date>
    </item>
    <item>
      <title>How to use state machines for your modeling (Part 4): The state machine as a table</title>
      <link>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modeling-part-4-the-state-machine-as-a-table</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modeling-part-4-the-state-machine-as-a-table" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/Modellieren%20mit%20Zustandsautomaten%20%E2%80%93%20Darstellung%20als%20Tabelle%20%E2%80%93%20Vorschau.png?t=1510753614328" alt="How to use state machines for your modeling (Part 4): The state machine as a table" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;In the first parts of our series "How to use state machines for your modeling", we have looked at the basics of state machines and graphical modelling (see &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-1"&gt;part 1&lt;/a&gt; and &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-2-time-controlled-triggering-of-state-transitions"&gt;part 2&lt;/a&gt;) and discovered the implementation by means of a &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-3-the-big-switch-statement"&gt;switch statement&lt;/a&gt;.&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;In the first parts of our series "How to use state machines for your modeling", we have looked at the basics of state machines and graphical modelling (see &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-1"&gt;part 1&lt;/a&gt; and &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-2-time-controlled-triggering-of-state-transitions"&gt;part 2&lt;/a&gt;) and discovered the implementation by means of a &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-3-the-big-switch-statement"&gt;switch statement&lt;/a&gt;.&lt;/p&gt;  
&lt;p&gt;Now let’s take a look at another approach, which is popular in automata theory: using &lt;a href="https://en.wikipedia.org/wiki/State_transition_table"&gt;state transition tables&lt;/a&gt; for the specification of state machines. The initial and target states, as well as the events that lead to a transition from the initial to a target state, are listed in a table that the implementation refers to repeatedly.&lt;/p&gt; 
&lt;h2&gt;One-dimensional state transition tables&lt;/h2&gt; 
&lt;p&gt;A one-dimensional state transition table defines one state transition per line. In the simplest case the table contains two columns: one contains all the initial states, the others the respective assigned states.&lt;/p&gt; 
&lt;p&gt;For a traffic light control it looks like this:&lt;/p&gt; 
&lt;table class="grey-theme"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;Active state&lt;/th&gt; 
   &lt;th&gt;Next state&lt;/th&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Red&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Red-Yellow&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Red-Yellow&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Green&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Green&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Yellow&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Yellow&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Red&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;The reality is, of course, more complex: a traffic light should not be rushing through its states in a fraction of a second. Instead it should remain in the current state for a specific time, then change to the next state. This behaviour can be approximated by a slow clock of, say, ten seconds. The state machine looks at the table at every clock pulse, checks what the current state is and changes to the following state.&lt;/p&gt; 
&lt;p&gt;However, the result would still be very unsatisfactory, because the yellow phases would be much too long and the red and green phases would be much too short. We need different durations in the individual phases. This can be achieved with time-controlled events, as already described. The change from the state &lt;strong&gt;Red&lt;/strong&gt; to &lt;strong&gt;Red-Yellow&lt;/strong&gt;, for example, takes place only after the occurrence of the event &lt;i&gt;20 s passed&lt;/i&gt;.&lt;/p&gt; 
&lt;p&gt;In single-dimensional state transition tables each event is usually assigned its own table column. Those state transitions – represented by the rows of the table – that should only take place when the event is present contain a checkmark in the corresponding cell:&lt;/p&gt; 
&lt;table class="grey-theme"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;Current state&lt;/th&gt; 
   &lt;th&gt;20 s passed&lt;/th&gt; 
   &lt;th&gt;3 s passed&lt;/th&gt; 
   &lt;th&gt;30 s passed&lt;/th&gt; 
   &lt;th&gt;Next state&lt;/th&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Red&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Red-Yellow&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Red-Yellow&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Green&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Green&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Yellow&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Yellow&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Red&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;The first line describes the state transition from &lt;strong&gt;Red&lt;/strong&gt; to &lt;strong&gt;Red-Yellow&lt;/strong&gt;. Since a check mark has been placed in the event column &lt;i&gt;20 s passed&lt;/i&gt;, the transition takes place only after this event has arrived. The events &lt;i&gt;3 s passed&lt;/i&gt; and &lt;i&gt;30 s passed&lt;/i&gt; here are irrelevant, so the check mark is omitted.&lt;/p&gt; 
&lt;h3&gt;Controlling a blind with the status transition table&lt;/h3&gt; 
&lt;p&gt;The state transition table for the blind control system looks like this:&lt;/p&gt; 
&lt;table class="grey-theme"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;Current state&lt;/th&gt; 
   &lt;th&gt;User.up&lt;/th&gt; 
   &lt;th&gt;User.down&lt;/th&gt; 
   &lt;th&gt;PosSensor.upperPosition&lt;/th&gt; 
   &lt;th&gt;PosSensor.lowerPosition&lt;/th&gt; 
   &lt;th&gt;Next state&lt;/th&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Initial&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Idle&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Idle&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span style="font-weight: 400;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Moving up&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Idle&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span style="font-weight: 400;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Moving down&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Moving up&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span style="font-weight: 400;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Idle&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Moving up&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span style="font-weight: 400;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Idle&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Moving down&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span style="font-weight: 400;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Idle&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Moving down&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p style="text-align: center;"&gt;&lt;span style="font-weight: 400;"&gt;&lt;span class="fa fa-check"&gt;yes&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Idle&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;h3&gt;&lt;strong&gt;The state transition table in the source code&lt;/strong&gt;&lt;/h3&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;This table can easily be converted into the source code of the desired programming language. We've already seen examples in Java, so here's something for C programmers:&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;#include 
#include 

enum states {
    INITIAL, IDLE, MOVING_UP, MOVING_DOWN
};

enum columns {
    SOURCE_STATE, USER_UP, USER_DOWN, POSSENSOR_UPPER_POSITION, POSSENSOR_LOWER_POSITION, TARGET_STATE
};

#define ROWS 7
#define COLS 6

int state_table[ROWS][COLS] = {

    /* source,     up,    down,  upper, lower, target */
    
    { INITIAL,     false, false, false, false, IDLE },
    { IDLE,        true,  false, false, false, MOVING_UP },
    { IDLE,        false, true,  false, false, MOVING_DOWN },
    { MOVING_UP,   false, true,  false, false, IDLE },
    { MOVING_UP,   false, false, true,  false, IDLE },
    { MOVING_DOWN, true,  false, false, false, IDLE },
    { MOVING_DOWN, false, false, false, true,  IDLE }
};&lt;/pre&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The enum &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;states&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; contains symbolic names of the states, simplifying the creation of the table &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;state_table&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. The enum &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;columns&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; assigns symbolic names to the column numbers. For example, the sample program below does not need to address the columns with the initial and target states, with their absolute indexes 0 and 5, but uses the symbolic names &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;SOURCE_STATE&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; and &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;TARGET_STATE&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. The symbolic names of the events are not needed in the sample program, but they are helpful for manual maintenance of the state transition table.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The table &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;state_table&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; specifies the state machine purely declaratively. If the machine changes, only adjustments to the table are necessary. This is clear as long as the number of states and events is small. If the number should increase, however, clarity and maintainability fall by the wayside. After all, the actual program code remains unchanged – an advantage because changes are simpler and less error-prone.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;We have already looked at the first part of the example implementation in C. The function &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;main&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; is shown below. The program asks for the number of the next event, which the user enters via the default input. The event numbers correspond to the position of the event in &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;columns&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, i.e. USER_UP = 1, USER_DOWN = 2 and so on. The machine then consults the table. If it finds a transition that triggers the entered event, the program informs the user of the row and column in the table and returns the number of the new state. These numbers correspond to the respective position in the enumeration &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;states&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;int main(int argc, char** argv) {

    int activeState = INITIAL;
    int event = -1;
    
    while (true) {
    
        int row, col;
    
        bool checkRows = true, checkCols;
    
        printf("Active state: %d\n", activeState);
        printf("Event: %d\n", event);
    
        /* Look for a row with the active state in the SOURCE_STATE column: */
        for (row = 0; checkRows &amp;amp;&amp;amp; row &amp;lt; ROWS; row++) {
    
           checkCols = true;
    
            if (activeState == state_table[row][SOURCE_STATE]) {
                /* Found a row matching the active state. */
                /* Now check the columns for events triggering this transition: */
    
                for (col = SOURCE_STATE + 1; checkCols &amp;amp;&amp;amp; col &amp;lt; TARGET_STATE; col++) {
    
                    if (state_table[row][col]) {
                        /* Found one. The current event must match this column
                         * to trigger the transition. */
    
                       if (event == col) {
                            /* The event matches. Let's do the transition: */
    
                            printf("Active state and event matching row %d, column %d.\n", row, col);
                            printf("Transitioning to target state %d\n", activeState);
    
                            activeState = state_table[row][TARGET_STATE];
    
                            /* Stop checking any further rows and columns: */
                            checkRows = checkCols = false;
    
                        } else {
                            /* The event does not match, so this transitions won't be triggered.
                             * We do not need to check any remaining columns: */
    
                            checkCols = false;
    
                        }
                    }
                }
    
                if (checkCols) {
    
                    /* At this point, we have checked all columns, but none of them requires an event
                     * for this transition. So we can do the transition in any case: */
    
                    printf("Transitioning without any event to target state %d\n", activeState);
                    
                    activeState = state_table[row][TARGET_STATE];
                    checkRows = false;
                }
            }
        }
    
        printf("Active state: %d\n\n", activeState);
        printf("Please enter event number!\n");
    
        scanf("%d", &amp;amp;event);
    }
}&lt;/pre&gt; 
&lt;p&gt;Attentive readers may notice that this implementation does not use a fixed clock, but is purely event-driven.&lt;/p&gt; 
&lt;h2&gt;Conditions and actions&lt;/h2&gt; 
&lt;p&gt;Unlike this example, transitions usually depend not only on events, but also on additional conditions (guard conditions). This means that a transition "pulls" not only if the right event is present, but also only if the guard condition is fulfilled. In the implementation, a transition is represented by a function that checks the condition.&lt;/p&gt; 
&lt;p&gt;The state transition table therefore does not encode any truth values, but instead has pointers to the relevant evaluation functions. In object-oriented languages this can be an object that contains the evaluation function. If the value is &lt;i&gt;zero&lt;/i&gt; in a table cell, this is equivalent to &lt;i&gt;false&lt;/i&gt;, that is, there is no transition for this combination of state and event. However, if the table contains a &lt;i&gt;nonzero&lt;/i&gt; value, this value is the pointer to an evaluation function. This is &lt;i&gt;true&lt;/i&gt; (i.e. non-zero) first; the transition is thus a candidate for execution in principle. The implementation now calls the function. This checks the guard condition and, based on its return value, determines whether or not the state machine should actually perform the transition.&lt;/p&gt; 
&lt;p&gt;Transitions and states can be linked to actions. Actions can also be left to the functions to which the state transition table refers. Such a function therefore not only checks the guard condition, but also activates the following state if the condition is fulfilled.&lt;/p&gt; 
&lt;p&gt;Concepts such as orthogonality, compound states or history states are difficult to implement with a table. In theory there is an equivalent representation for each of these constructs as a flat state machine, but in practice the state space explodes very quickly. For example, to map orthogonal regions in a flat automatic state machine there must be a separate state for each permutation of the active states in the orthogonal regions. The number of these states is given by the cross-product of the states in the orthogonal regions. In two orthogonal regions, each with three states, nine flat states may still be possible, but there are 810 flat states in ten orthogonal regions each with eight states. That is more than a billion.&lt;/p&gt; 
&lt;h2&gt;Two-dimensional state transition tables&lt;/h2&gt; 
&lt;p&gt;Two-dimensional transition tables are generally more compact than one-dimensional tables, because a single row is sufficient per output state. The respective target state is noted in the cells in which output state lines intersect with event columns. In the following table the event &lt;i&gt;User.down&lt;/i&gt; (third column) in the &lt;strong&gt;Idle&lt;/strong&gt; state (second row) leads to the target state &lt;strong&gt;Moving down&lt;/strong&gt;.&lt;/p&gt; 
&lt;table class="grey-theme"&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;th&gt;Current state&lt;/th&gt; 
   &lt;th&gt;User.up&lt;/th&gt; 
   &lt;th&gt;User.down&lt;/th&gt; 
   &lt;th&gt;PosSensor.upperPosition&lt;/th&gt; 
   &lt;th&gt;PosSensor.lowerPosition&lt;/th&gt; 
   &lt;th&gt;No event&lt;/th&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Initial&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Idle&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Idle&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Moving up&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Moving down&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Moving up&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Idle&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Idle&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;Moving down&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Idle&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;Idle&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt;&amp;nbsp;&lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt; 
&lt;p&gt;The implementation basically looks the same as for one-dimensional tables. A truth value is no longer sufficient for the table cells; instead the respective target state must be encoded. If we want to consider the guard conditions and actions associated with transitions, we need a pointer to a function that corresponds to the transition and implicitly contains the subsequent state. These are as a rule quite different functions for the same subsequent state.&lt;/p&gt; 
&lt;p&gt;In the following parts of this series, we will learn about the object-oriented “State” software design pattern. We will compare the three implementation approaches – and see how automatic code generation with &lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools&lt;/a&gt; can help save the overall implementation effort.&lt;/p&gt; 
&lt;p&gt;To read the whole “How to use state machines for your modeling” series, download our whitepaper for free.&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=11a95e87-0e67-4562-beaa-35526a9e7616&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Download free whitepaper now" src="https://no-cache.hubspot.com/cta/default/761475/11a95e87-0e67-4562-beaa-35526a9e7616.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fhow-to-use-state-machines-for-your-modeling-part-4-the-state-machine-as-a-table&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Mon, 04 Sep 2017 14:10:00 GMT</pubDate>
      <author>rainer.klute@itemis.de (Rainer Klute)</author>
      <guid>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modeling-part-4-the-state-machine-as-a-table</guid>
      <dc:date>2017-09-04T14:10:00Z</dc:date>
    </item>
    <item>
      <title>How to use state machines for your modeling (Part 3): The big switch statement</title>
      <link>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modelling-part-3-the-big-switch-statement</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modelling-part-3-the-big-switch-statement" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/Switch-Statement.jpg?t=1510753614328" alt="How to use state machines for your modeling (Part 3): The big switch statement" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;Having read part 1 and part 2 of this series, we should now have a &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-1"&gt;better understanding of state machines, basic elements of the graphical modeling language&lt;/a&gt;&amp;nbsp;and &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-2-time-controlled-triggering-of-state-transitions"&gt;time-controlled state transitions&lt;/a&gt;.&amp;nbsp;&lt;span style="background-color: transparent;"&gt;In the following sections we examine how model code is created from modeled state machines.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;Having read part 1 and part 2 of this series, we should now have a &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-1"&gt;better understanding of state machines, basic elements of the graphical modeling language&lt;/a&gt;&amp;nbsp;and &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-2-time-controlled-triggering-of-state-transitions"&gt;time-controlled state transitions&lt;/a&gt;.&amp;nbsp;&lt;span style="background-color: transparent;"&gt;In the following sections we examine how model code is created from modeled state machines.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;Whoever models the blind control system not only needs it as an example, but will want to use it to create a real control unit, and so needs executable code. We will look at different implementation approaches for state automata and preview the automatic code generation abilities of &lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools&lt;/a&gt;.&lt;br&gt;&lt;br&gt;&lt;/p&gt; 
&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt; 
&lt;h2&gt;The big switch statement&lt;/h2&gt; 
&lt;p&gt;Various approaches are possible for implementing an automatic state machine in software. The most common is using a switch statement. Developers often implement state-of-the-art switches with switch instructions, even if they are not aware that they are state machines. Each state of the machine corresponds to one of the case clauses of the switch statement. The program jumps to the case clause that corresponds to the active state. Within this case clause, it executes state-specific statements, checks whether and/or which events are present, and activates a different state depending on them.&lt;/p&gt; 
&lt;p&gt;In principle two variants are standard:&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;In the event-driven approach, the state machine executes the switch instruction as soon as an event arrives.&lt;/li&gt; 
 &lt;li&gt;In the cycle-based approach, this is done at regular intervals.&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;A combination of both approaches is also possible. Executing the switch statement and processing the current events is called &lt;i&gt;run-to-completion-step (RTC)&lt;/i&gt;.&lt;/p&gt; 
&lt;p&gt;The basic structure of the implementation can be sketched very simply using the example of a traffic light, because each state of a traffic light is always assigned exactly one following state: red follows red-yellow, then green, then yellow and then red again. This state machine does currently not need any events, which results in simple and clear source code.&lt;/p&gt; 
&lt;p&gt;We choose Java as an implementation language here, but of course this principle can also be implemented analogously in other programming languages. First we define an enumeration with all states of the state automaton, i.e. with the traffic light phases.&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;enum State {
    RED, RED_YELLOW, GREEN, YELLOW
}&lt;/pre&gt; 
&lt;p&gt;The variable &lt;em&gt;activeState&lt;/em&gt; contains the current status; this is initialized to red.&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;State activeState = State.RED;&lt;/pre&gt; 
&lt;p&gt;The &lt;i&gt;stateMachine&lt;/i&gt; method implements the actual state automata. Its core is a switch statement, which, depending on the current state, activates the next state by assigning it to &lt;i&gt;activeState&lt;/i&gt;. In this example this occurs cyclically in an endless loop.&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;public void stateMachine() {
    while (true) {
       switch (activeState) {

            case RED: {
                activeState = State.RED_YELLOW;
                break;
            }
    
            case RED_YELLOW: {
                activeState = State.GREEN;
                break;
            }
    
           case GREEN: {
                activeState = State.YELLOW;
                break;
            }
    
            case YELLOW: {
                activeState = State.RED;
                break;
            }

        }
    }
}&lt;/pre&gt; 
&lt;p&gt;The next example goes one step further and takes events into account. For this purpose we will return to the blind control, as shown in the figure below.&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/yakindu/statechart-tools/Blogs/Modellieren_Zustandsautomaten/vbc_02.png?t=1510753614328&amp;amp;width=651&amp;amp;height=426&amp;amp;name=vbc_02.png" alt="vbc_02.png" width="651" height="426" style="display: block; margin-left: auto; margin-right: auto;"&gt; 
&lt;p&gt;&lt;br&gt;The implementation in Java summarizes the states of the machine in the enum &lt;i&gt;State&lt;/i&gt;:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;enum State {
    INITIAL, IDLE, MOVING_UP, MOVING_DOWN
}&lt;/pre&gt; 
&lt;p&gt;The events can also be represented in an enum:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;enum Event {
    USER_UP, USER_DOWN, POSSENSOR_UPPER_POSITION, POSSENSOR_LOWER_POSITION
}&lt;/pre&gt; 
&lt;p&gt;The variable &lt;i&gt;activeState&lt;/i&gt; is preset with the initial state of the machine:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;State activeState = State.INITIAL;&lt;/pre&gt; 
&lt;p&gt;The &lt;i&gt;Collection&amp;lt;Event&amp;gt; events&lt;/i&gt; records the incoming events:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;Collection events = new ArrayList();&lt;/pre&gt; 
&lt;p&gt;For developers who are unfamiliar with Java, &lt;i&gt;Collection&amp;lt;Event&amp;gt;&lt;/i&gt; is a data type that manages a group of event objects. The example uses an &lt;i&gt;ArrayList&amp;lt;Event&amp;gt;&lt;/i&gt; as a concrete implementation, a list of &lt;i&gt;event&lt;/i&gt; objects that is implemented internally using an array.&lt;/p&gt; 
&lt;p&gt;The following idea lies behind this. As we have seen, the state machine continuously executes the switch statement in an endless loop. The state machine should only do something if there is actually something to do, for example to save power, or to prevent a multitasking system from unnecessarily hogging CPU capacity. The endless loop therefore does not run at the highest possible speed, but at a suitable, lower rate. That is, the machine executes one cycle (run-to-completion step) and then pauses for a while. This power saving effect is particularly important for embedded devices without external power supplies. In this example the waiting time between two cycles is 100 milliseconds:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;long clockPulse = 100;&lt;/pre&gt; 
&lt;p&gt;Events can arrive within this waiting period: we leave how this happens outside this discussion. In any case, these events enter the collection defined above and can be evaluated in the next processing cycle. If the blind control is in the &lt;strong&gt;Idle&lt;/strong&gt; state and the &lt;i&gt;User.up&lt;/i&gt; event is present, the state machine switches to the &lt;strong&gt;Moving up&lt;/strong&gt; state. The event &lt;i&gt;User.down&lt;/i&gt; is a transition to &lt;strong&gt;Moving down&lt;/strong&gt;. The Java code that implements this function looks like this:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;case IDLE: {
    if (events.contains(Event.USER_UP))
        activeState = State.MOVING_UP;

    else if (events.contains(Event.USER_DOWN))
        activeState = State.MOVING_DOWN;

    break;
}&lt;/pre&gt; 
&lt;p&gt;If any other events arrive while &lt;strong&gt;Idle&lt;/strong&gt; is the active state they are ignored: a state machine should respond by definition only to those events for which the respective active state is "sensitive".&lt;/p&gt; 
&lt;p&gt;Several events may be present simultaneously. The lower the clock rate, the greater the probability is that a user will press both the [↑] and [↓] keys between two processing cycles. In this case, in the above implementation the [↑] key always "wins". If you want to give priority to the [↓] key, you must adapt the implementation accordingly.&lt;/p&gt; 
&lt;p&gt;Here is the complete method &lt;i&gt;stateMachine&lt;/i&gt;, which implements the behaviour of the automatic state machine:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;public void stateMachine() {
    while (true) {

        /* Act upon the active state: */
        switch (activeState) {
    
            case INITIAL: {
                activeState = State.IDLE;
                break;
            }
            
            case IDLE: {
                if (events.contains(Event.USER_UP))
                    activeState = State.MOVING_UP;
            
                else if (events.contains(Event.USER_DOWN))
                    activeState = State.MOVING_DOWN;
            
                break;
            }
            
            case MOVING_UP: {
                if (events.contains(Event.POSSENSOR_UPPER_POSITION) || events.contains(Event.USER_DOWN))
                    activeState = State.IDLE;
            
                break;
            }
            
            case MOVING_DOWN: {
                if (events.contains(Event.POSSENSOR_LOWER_POSITION) || events.contains(Event.USER_UP))            
                    activeState = State.IDLE;

                break;            
            }
            
            default: {
                /* Should never happen. */
                throw (new IllegalStateException());
            }
        }&lt;/pre&gt; 
&lt;p&gt;We have already seen that at most one event leads to a state transition within a single clock cycle. This will have already happened at this point if there was a suitable event. Whether we are in a new state or still in the same state as before, the events that arrived during the last cycle have no further relevance. For the next cycle we must clear them:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;       /* Clear events: */
        events.clear();&lt;/pre&gt; 
&lt;p&gt;The current processing cycle is thus completed. The state machine now pauses &lt;i&gt;clockPulse&lt;/i&gt; milliseconds:&lt;/p&gt; 
&lt;pre class="prettyprint"&gt;       /* Pause until the next run to completion step is due: */
        try {
            Thread.sleep(clockPulse);

        } catch (InterruptedException e) {
           // Ignore
        }
    }
}&lt;/pre&gt; 
&lt;p&gt;In the following parts of this series, we will learn about two other implementation approaches: the representation of state machines as a table and – as an object-oriented variant – the “State” software design pattern.&lt;/p&gt; 
&lt;p&gt;In addition, we will take a brief look at &lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;YAKINDU Statechart Tools&lt;/a&gt;’ automatic code generation feature.&lt;/p&gt; 
&lt;p&gt;To read the whole “How to use state machines for your modeling” series, download our whitepaper for free.&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=11a95e87-0e67-4562-beaa-35526a9e7616&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Download free whitepaper now" src="https://no-cache.hubspot.com/cta/default/761475/11a95e87-0e67-4562-beaa-35526a9e7616.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fhow-to-use-state-machines-for-your-modelling-part-3-the-big-switch-statement&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Tue, 29 Aug 2017 09:03:00 GMT</pubDate>
      <author>rainer.klute@itemis.de (Rainer Klute)</author>
      <guid>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modelling-part-3-the-big-switch-statement</guid>
      <dc:date>2017-08-29T09:03:00Z</dc:date>
    </item>
    <item>
      <title>TypeScript code generation with YAKINDU Statechart Tools</title>
      <link>https://blogs.itemis.com/en/typescript-code-generation-with-yakindu-statechart-tools</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/typescript-code-generation-with-yakindu-statechart-tools" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/yakindu-ts-angular-ionic-preview.jpg?t=1510753614328" alt="TypeScript code generation with YAKINDU Statechart Tools" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;div class="infobox"&gt; 
 &lt;p style="text-align: left;"&gt;&lt;span style="font-weight: 400;"&gt;Researching, prototyping and putting our ideas into code, aside from the day-to-day business, is an &lt;/span&gt;&lt;a href="/en/4-1-wins-a-somewhat-different-working-time-model"&gt;&lt;span&gt;essential part of the itemis company culture&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;. YAKINDU Labs is a collection of such projects which are currently in beta phase and therefore not yet released with any YAKINDU product bundles. As we love early feedback we&amp;nbsp;&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;regularly blog about what’s going on behind the scenes. So try it, and get in touch with us!&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;To handle the complexity of modern web applications, model-driven development comes to your rescue. This blog post will show you how to model your web application’s behavior with state machines and transform the latter into TypeScript code directly.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;div class="infobox"&gt; 
 &lt;p style="text-align: left;"&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/yakindu-labs-logo.png?t=1510753614328&amp;amp;width=316&amp;amp;name=yakindu-labs-logo.png" alt="yakindu-labs-logo.png" width="316" style="margin: 0px 10px 10px 0px; width: 316px; float: left;"&gt;Researching, prototyping and putting our ideas into code, aside from the day-to-day business, is an &lt;/span&gt;&lt;a href="/en/4-1-wins-a-somewhat-different-working-time-model"&gt;&lt;span&gt;essential part of the itemis company culture&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;. YAKINDU Labs is a collection of such projects which are currently in beta phase and therefore not yet released with any YAKINDU product bundles. As we love early feedback we&amp;nbsp;&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;regularly blog about what’s going on behind the scenes. So try it, and get in touch with us!&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;To handle the complexity of modern web applications, model-driven development comes to your rescue. This blog post will show you how to model your web application’s behavior with state machines and transform the latter into TypeScript code directly.&amp;nbsp;&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The generated code can easily be integrated with modern web development frameworks, like Angular or Ionic.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/yakindu-ts-angular-ionic.png?t=1510753614328&amp;amp;width=724&amp;amp;height=424&amp;amp;name=yakindu-ts-angular-ionic.png" alt="yakindu-ts-angular-ionic.png" width="724" height="424"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Single-page web applications&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;TypeScript is a free and open-source programming language developed and maintained by Microsoft. It is a strict syntactical superset of JavaScript and adds optional typing to the language. TypeScript is designed for development of large web applications and compiles to JavaScript. As it is a superset of JavaScript, existing JavaScript programs are also valid TypeScript programs – that means you don’t need to go through a big rewrite to migrate them. TypeScript brings a lot of features you already know from other higher-level programming languages like Java. Some examples:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Type annotations and compile-time type checking&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Type inference &lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Interfaces&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Enumerated types&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Mixins&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Generics&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;NameSpaces&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Classes&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Modules&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;And much more&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Some modern web frameworks like Angular 2+ &amp;nbsp;or Ionic 2+ are based on TypeScript. These frameworks make use of the advantages of TypeScript when building scalable single-page web applications. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Since more logic is moved to the frontend, single-page web applications easily become complex. This is especially true for the interaction logic. This logic often ends op to be cluttered across the different parts of the application like event handlers, observables, etc.. In order to organize this better developers often end up in writing TypeScript classes that more or less implement state machines. At this point it is possible to go beyond typical implementation approaches and allow developers &amp;nbsp;to model an application’s behavior graphically as a state machine and to transform it directly into TypeScript code using tools like &lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Statechart Tools&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Web-based car infotainment app&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In this example, we will have a look at an application with a simple HMI (Human Machine Interface) that represents an infotainment system for cars.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;This application consists of two screens:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;strong&gt;welcome screen&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;: shows a welcome animation&lt;/span&gt;&lt;/li&gt; 
 &lt;li style="font-weight: 400;"&gt;&lt;strong&gt;main Screen&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;: consists of severals components (speedometer, light widgets, infotainment…).&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The infotainment component represents a container for further components like &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;infotainment menu&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;weather&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;music player&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; and &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;phone&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;On the right-hand side of the image below you can see the menu with three items. If you click on an item, the corresponding feature will be displayed.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/human-machine-interface-car-infotainment.gif?t=1510753614328&amp;amp;width=724&amp;amp;name=human-machine-interface-car-infotainment.gif" alt="human-machine-interface-car-infotainment.gif" width="724" style="width: 724px;"&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;The demonstrated behavior is modelled with YAKINDU Statechart Tools as follows:&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/hmi-yakindu-statechart-tools.png?t=1510753614328&amp;amp;width=724&amp;amp;height=403&amp;amp;name=hmi-yakindu-statechart-tools.png" alt="hmi-yakindu-statechart-tools.png" width="724" height="403"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/yakindu-statechart-tools-menu-service.png?t=1510753614328&amp;amp;width=312&amp;amp;height=303&amp;amp;name=yakindu-statechart-tools-menu-service.png" alt="yakindu-statechart-tools-menu-service.png" width="312" height="303" style="margin: 0px 10px 10px 0px; float: left;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In the definition section we define a &lt;/span&gt;&lt;em&gt;menuState&lt;/em&gt;&lt;span style="font-weight: 400;"&gt; variable of type string. The &lt;em&gt;menuState&lt;/em&gt; is used to decide which state is to be entered.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Then we define an &lt;/span&gt;&lt;em&gt;inevent onMenuChanged&lt;/em&gt;&lt;span style="font-weight: 400;"&gt; to respond to user interactions. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Finally, we define four &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;operation callbacks&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; which display the corresponding feature.&lt;/span&gt;&lt;/p&gt; 
&lt;br&gt;
&lt;br&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Generating TypeScript artifacts&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;To configure the code generation process, YAKINDU Statechart Tools uses a textual generator model called &lt;i&gt;&lt;span style="font-weight: 400;"&gt;SGen&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. It describes what should be generated where, and with which options. The generator model can be created either by using the provided &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Statechart Generator Model&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; wizard or by creating a text file with the extension &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;.sgen&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/yakindu-statechart-tools-generator-model.png?t=1510753614328&amp;amp;width=724&amp;amp;name=yakindu-statechart-tools-generator-model.png" alt="yakindu-statechart-tools-generator-model.png" width="724" style="width: 724px;"&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Using the &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;Outlet&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; feature, we specify that our target project is &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;ycar_app&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The generated artifact should be placed into the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;src/app/gen/statemachine&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; directory within the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;ycar_app&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; project.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The generated state machine has some dependencies. They are generated into the library target folder &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;src/app/gen/stateutils&lt;/span&gt;&lt;/i&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;Using the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;GeneratorFeatures&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, we specify that our statechart should be created as an Angular service (useAngular = true) with an event-driven behavior (useEventQueue = true).&lt;/span&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Integrating the generated menu service state machine into Angular&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In context of Angular, the generated &lt;i&gt;&lt;span style="font-weight: 400;"&gt;MenuService&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; state machine was created as an Angular service. The state machine needs to be added as a provider to &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;YMainScreenModule&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;br&gt; &lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/yakindu-statechart-tools-main-screen-module.png?t=1510753614328&amp;amp;width=724&amp;amp;name=yakindu-statechart-tools-main-screen-module.png" alt="yakindu-statechart-tools-main-screen-module.png" width="724" style="width: 724px;"&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;Next we have to customize the &lt;i&gt;&lt;span style="font-weight: 400;"&gt;YMainScreenComponent&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; to inject the service and write some glue code for setting the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;in&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; events and the operation callbacks. We do that in the component lifecycle hook &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;ngAfterViewInit:&lt;/span&gt;&lt;/i&gt;&lt;br&gt;&lt;br&gt; &lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/yakindu-statechart-tools-main-screen-component.png?t=1510753614328&amp;amp;width=640&amp;amp;name=yakindu-statechart-tools-main-screen-component.png" alt="yakindu-statechart-tools-main-screen-component.png" width="640" style="width: 640px; display: block; margin-left: auto; margin-right: auto;"&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;From line 34 to 47 we define an operation callback object of type &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;IOperationCallback&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. The members of this object are callback functions that are called from &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;menuService&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In line 48 the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;menuOperationCallback&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; object is passed as an argument to the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;setdefaultScopeOperationCallback&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; function.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;mainScreenService.menuChanged&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; observable is subscribed. Depending on the value of &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;menuState&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;menuService.menuState&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; will be set.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Try it yourself!&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The demonstrated example is available in full in the &lt;/span&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/examples/"&gt;&lt;span style="font-weight: 400;"&gt;example wizard of YAKINDU Statechart Tools&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;. However, since the TypeScript generator is still in its beta testing phase, it does not come bundled with the YAKINDU Statechart Tools out of the box yet. Instead you have to install it manually. To do so, please go to &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Help → Install New Software&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; and select &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Typescript Generator&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; from our update site, as shown in the screenshot below.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/yakindu-statechart-tools-typescript-generator.png?t=1510753614328&amp;amp;width=721&amp;amp;height=310&amp;amp;name=yakindu-statechart-tools-typescript-generator.png" alt="yakindu-statechart-tools-typescript-generator.png" width="721" height="310"&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Once you have installed the generator, you can import the project &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Web-based YCar App&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; from our example wizard, which you can invoke using &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;File → New → Example… → YAKINDU Statechart Examples&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Try it out and have some fun!&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Conclusion&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Web applications are becoming increasingly complex. To make the complexity manageable, it pays out to implement parts of an application in a model-driven way. &lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In this blog post I have described how to configure the generation process for our modelled state machine. I have shown how simple it is to integrate a generated TypeScript artifact, here: the state machine, to an existing Angular application. The only thing we still have to do, is to customize the Angular module and their component that uses the generated Angular service. &amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;What’s coming next? Okay, it’s really cool to generate TypeScript code from a state machine, but what would you say if you could use existing TypeScript artifacts directly in a statechart, similar to our &lt;/span&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/user-guide/#cdom_deep-c-integration"&gt;&lt;span style="font-weight: 400;"&gt;deep C integration&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt; – one of the main features of YAKINDU Statechart Tools? Yes, we are already working on that, and the development is well advanced. Stay tuned for more information about this!&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Ftypescript-code-generation-with-yakindu-statechart-tools&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <category>YAKINDU Labs</category>
      <pubDate>Fri, 25 Aug 2017 09:17:00 GMT</pubDate>
      <author>dennis.van.der.vlugt@itemis.de (Dennis van der Vlugt)</author>
      <guid>https://blogs.itemis.com/en/typescript-code-generation-with-yakindu-statechart-tools</guid>
      <dc:date>2017-08-25T09:17:00Z</dc:date>
    </item>
    <item>
      <title>How to integrate YAKINDU Statechart Tools in your IDE step by step</title>
      <link>https://blogs.itemis.com/en/how-to-integrate-yakindu-statechart-tools-in-your-ide-step-by-step</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/how-to-integrate-yakindu-statechart-tools-in-your-ide-step-by-step" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/puzzleteile-zusammenfu%CC%88gen.jpg?t=1510753614328" alt="puzzleteile-zusammenfügen.jpg" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;You want to use YAKINDU Statechart Tools, but you do not want to bloat your toolchain by yet another tool? Here’s how we can help.&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="background-color: transparent;"&gt;You want to use YAKINDU Statechart Tools, but you do not want to bloat your toolchain by yet another tool? Here’s how we can help.&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;We integrate ourselves into your IDE!&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Statechart Tools&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt; is developed within Eclipse. Simplified, it’s a bunch of plugins, which can be installed into any Eclipse-based product. A lot of other integrated development environments (IDEs) are also based on Eclipse. So, usually it is possible to simply add YAKINDU Statechart Tools to your (Eclipse-based) IDE instead of using our full-blown product application.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In this article, I will show you how to check if and how you can install YAKINDU Statechart Tools directly into your IDE.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Why would you want to do that?&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Software development kits for microcontrollers are typically delivered with an IDE that provides the complete toolchain needed for editing and compiling source code as well as for uploading the compiled binaries to the target platform. It would be a hassle if you had to develop your statechart in a separate tool and copy the generated source over to the IDE each time the statechart is modified. With YAKINDU Statechart Tools being part of your IDE, you can seamlessly edit statecharts and source code in the same tool, simulate statecharts, generate and compile source code, and upload binaries to the microcontroller.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Checking the IDE&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In order to integrate YAKINDU Statechart Tools, your integrated development environment must be based on Eclipse. This is a mandatory requirement. To show you the steps, I will use Code Composer Studio by Texas Instruments, where I’ve already installed YAKINDU Statechart Tools. Look for the “Help” drop-down menu.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Code-Composer-Studio-Help.png?t=1510753614328&amp;amp;width=459&amp;amp;height=435&amp;amp;name=Code-Composer-Studio-Help.png" alt="Code-Composer-Studio-Help.png" width="459" height="435" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Click on “About &amp;lt;your IDE name&amp;gt;”. In the open dialog you can click on the Eclipse.org symbol and find your Eclipse platform version.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Code-Composer-Studio-your-IDE.png?t=1510753614328&amp;amp;width=724&amp;amp;height=106&amp;amp;name=Code-Composer-Studio-your-IDE.png" alt="Code-Composer-Studio-your-IDE.png" width="724" height="106" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;You need at least version 4.5.x (Mars).&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;If your IDE is based on Eclipse 4.5.x or higher, the next thing you need to find out, is whether your IDE allows you to install new software. Some IDEs don’t support that. If you find a menu entry &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“Install New Software”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; in the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“Help”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; menu, you’re ready.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Installing YAKINDU Statechart Tools&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now you can install YAKINDU Statechart Tools.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;Make sure&lt;/span&gt;&lt;span style="background-color: transparent;"&gt; &lt;/span&gt;&lt;span style="font-weight: 400;"&gt;to click on the &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;“Install from update site”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; option. You can choose between &lt;/span&gt;&lt;a href="/en/introducing-yakindu-statechart-tools-standard-edition-3.0"&gt;&lt;span&gt;Standard&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt; and &lt;/span&gt;&lt;a href="/en/yakindu-statechart-tools-3.0-professional-edition-new-and-noteworthy"&gt;&lt;span&gt;Professional&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt; Edition.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/YAKINDU-Statechart-Tools-Download-Versions.png?t=1510753614328&amp;amp;width=546&amp;amp;height=366&amp;amp;name=YAKINDU-Statechart-Tools-Download-Versions.png" alt="YAKINDU-Statechart-Tools-Download-Versions.png" width="546" height="366" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Copy the link so that you have it at hand during the next step.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Go back to your IDE and click on &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“Install New Software…”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; in the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“Help”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; menu.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Code-Composer-Studio-install-software.png?t=1510753614328&amp;amp;width=724&amp;amp;height=566&amp;amp;name=Code-Composer-Studio-install-software.png" alt="Code-Composer-Studio-install-software.png" width="724" height="566"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;Click on &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“Add…”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. In the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“Add Repository”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; dialog, enter “YAKINDU Statechart Tools” into the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“Name”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; text field and paste the URL of the update site into the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“Location”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; field. Click on &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“OK”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. The IDE will contact the YAKINDU Statechart Tools update site and display the available software components. Depending on which licence you have, check either YAKINDU Statechart Tools Professional Edition or Standard Edition.&lt;br&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/YAKINDU-Statechart-Tools-Edition.png?t=1510753614328&amp;amp;width=451&amp;amp;name=YAKINDU-Statechart-Tools-Edition.png" alt="YAKINDU-Statechart-Tools-Edition.png" width="451" style="display: block; margin-left: auto; margin-right: auto; width: 451px;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Start the installation by clicking on &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;“Next”&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; and following the installation instructions. After the installation, a restart of the IDE is required.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now you have successfully installed YAKINDU Statechart Tools in your IDE.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;If you want to learn more about how to use YAKINDU Statechart Tools within your IDE check our blog post “&lt;a href="/en/how-to-program-a-msp430-with-state-machines-in-5-minutes"&gt;How to program a MSP430 with state machines in 5 minutes&lt;/a&gt;”.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Troubleshooting&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Statechart Tools has got some dependencies on other update sites. For example, Code Composer Studio additionally needs the Eclipse Neon update site. You can find all of them in the list of required dependencies. If you encounter any dependency problems during your installation, try to add the listed dependencies.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;span style="font-weight: 400;"&gt;I’ve successfully installed and tested YAKINDU Statechart Tools in TI’s&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;Code Composer Studio&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;v7.1.0, Atollic’s&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;TRUEStudio&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;for ARM v 7.1.2 and NXP’s&lt;span&gt;&amp;nbsp;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;LPCXpresso IDE&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;&lt;span&gt;&amp;nbsp;&lt;/span&gt;v8.2.2.&amp;nbsp;&lt;/span&gt;Now it’s your turn. Find out if you got an Eclipse-based IDE and try to install YAKINDU Statechart Tools. Please contact me if you got any problems during the installation. &lt;br&gt;&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt; 
&lt;h2&gt;&lt;span style="font-weight: 400;"&gt;Dependencies&lt;/span&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;a href="http://download.eclipse.org/eclipse/updates/4.6"&gt;&lt;span style="font-weight: 400;"&gt;http://download.eclipse.org/eclipse/updates/4.6&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="http://download.eclipse.org/egit/updates-4.5/"&gt;&lt;span style="font-weight: 400;"&gt;http://download.eclipse.org/egit/updates-4.5/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a href="http://download.eclipse.org/releases/neon"&gt;&lt;span style="font-weight: 400;"&gt;http://download.eclipse.org/releases/neon&lt;/span&gt;&lt;/a&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a href="http://download.eclipse.org/tools/orbit/downloads/drops/R20140525021250/repository/"&gt;http://download.eclipse.org/tools/orbit/downloads/drops/R20140525021250/repository/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fhow-to-integrate-yakindu-statechart-tools-in-your-ide-step-by-step&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Fri, 18 Aug 2017 14:36:00 GMT</pubDate>
      <author>robin.herrmann@itemis.de (Robin Herrmann)</author>
      <guid>https://blogs.itemis.com/en/how-to-integrate-yakindu-statechart-tools-in-your-ide-step-by-step</guid>
      <dc:date>2017-08-18T14:36:00Z</dc:date>
    </item>
    <item>
      <title>How to use state machines for your modeling (Part 2): Time-controlled triggering of state transitions</title>
      <link>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modelling-part-2-time-controlled-triggering-of-state-transitions</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modelling-part-2-time-controlled-triggering-of-state-transitions" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/Stockmaterial_allgemein/Fotolia_77179099_S.jpg?t=1510753614328" alt="How to use state machines for your modeling (Part 2): Time-controlled triggering of state transitions" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;In the first part of this series, we used &lt;span&gt;YAKINDU Statechart Tools&lt;/span&gt;&lt;span style="font-weight: 400;"&gt; to &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-1"&gt;model the behaviour of a blind control as a state machine&lt;/a&gt;, and we discovered basic elements of the modeling language, such as states, transitions, or events.&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;In the first part of this series, we used &lt;span&gt;YAKINDU Statechart Tools&lt;/span&gt;&lt;span style="font-weight: 400;"&gt; to &lt;a href="/en/how-to-use-state-machines-for-your-modelling-part-1"&gt;model the behaviour of a blind control as a state machine&lt;/a&gt;, and we discovered basic elements of the modeling language, such as states, transitions, or events.&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In this second part we will look at other concepts and issues:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="background-color: transparent;"&gt;How can actions be initiated based on clock time?&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;How can a state have internal states (composite state)?&lt;span style="font-weight: 400;"&gt;&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;How can different state automatons work side by side (orthogonal regions)?&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The processing of elapsed time and reaction to it are important concepts for automatic state machines. Some examples might be:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="font-weight: 400;"&gt;&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;A traffic light control system that controls the respective duration of the red, yellow and green phases, either periodically – i.e. time-controlled – or triggered by requests.&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="font-weight: 400;"&gt;In technical installations – from the simple coffee machine example through motor vehicles to a nuclear power plant – maintenance intervals must be observed to ensure the proper functioning of the system. Maintenance might be triggered by specific performance issues of the system, or by a time sequence, whichever occurs first.&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="font-weight: 400;"&gt;An administrative act might become legally effective after the expiry of a period for its opposition unless an objection is filed beforehand.&lt;/span&gt;&lt;span style="font-weight: 400;"&gt;&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="font-weight: 400;"&gt;In a data communication protocol with a positive acknowledgment method, a message may be deemed lost if the sender does not receive a reception acknowledgment from the recipient within a predetermined time (timeout).&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;All these scenarios can be modeled using state machines and either directly controlled by software (traffic light, data communication) or supported by it (maintenance, administrative act).&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/Stockmaterial_allgemein/Fotolia_77179099_S.jpg?t=1510753614328&amp;amp;width=724&amp;amp;height=362&amp;amp;name=Fotolia_77179099_S.jpg" alt="Fotolia_77179099_S.jpg" width="724" height="362"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;br&gt;We will extend our blind control system with time-controlled events to show how to operate the blinds automatically depending on the ambient brightness. In bright sun the blind should darken the room: if the brightness decreases, the blind should go up. We have already implemented a similar requirement: raising the blind in a strong wind to avoid damage. Since the wind speed always has priority over user requests, the modelling was quite simple, limited to two state transitions that trigger in strong winds and an additional condition that prevents the user from moving the blind down.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Controlling the blind based on environmental brightness is more complex, because different influencing variables intermesh. On one hand the blind control should react to the ambient brightness as described and adjust the blind automatically. On the other hand, users’ wishes should be taken into account: if someone wants bright sunlight in the room and operates a blind that has been lowered automatically, the blind control system should respect this choice and not try to oppose the users’ actions. If the user does not operate the blind for an extended period of time – this is where the time aspect comes into play – or if they have left the room, automatic behaviour should be resumed.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The basic idea is simple and can be explained by the following state machine:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Modellieren_mit_Zustandstandsautomaten_Teil2_Abbildung1.png?t=1510753614328&amp;amp;width=724&amp;amp;height=346&amp;amp;name=Modellieren_mit_Zustandstandsautomaten_Teil2_Abbildung1.png" alt="Modellieren_mit_Zustandstandsautomaten_Teil2_Abbildung1.png" width="724" height="346"&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The statechart above is limited to measuring the ambient brightness and initiating a corresponding response. Initially the state machine is in the state &lt;/span&gt;&lt;strong&gt;Sensing&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;, in which it continuously polls the ambient brightness. As soon as the brightness – contained in the variable &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Sun.brightness&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; – reaches or exceeds the specified &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Sun.BRIGHT&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; threshold value, the machine performs the transition &lt;/span&gt;&lt;strong&gt;Sensing → Waiting&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. This transition triggers the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Sun.down&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; event, which is intended to shut the blind.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In the &lt;/span&gt;&lt;strong&gt;Waiting&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; state nothing happens. Users can adjust the blind as they like and the automatic operation will not intervene as long as the wait is active. However, this is not always the case: the transition&lt;/span&gt;&lt;strong&gt; Waiting → Sensing&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; returns to the state in which the control system measures the sun’s brightness and responds accordingly. This transition is triggered "after 4 * 60 * 60 s", i.e. four hours after activation of the &lt;/span&gt;&lt;strong&gt;Waiting&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; state.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Combining several state machines&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;It would be nice if we could combine this simple state machine with the one we have already developed, so that the generated event &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Sun.down &lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;is effective there. The result looks like this:&lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung2.png?t=1510753614328&amp;amp;width=724&amp;amp;height=503&amp;amp;name=Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung2.png" alt="Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung2.png" width="724" height="503"&gt;
&lt;br&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;This figure shows two so-called &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;orthogonal&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; regions. Both contain their own state diagram. While the area &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;main region&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; is waiting for a user request or strong wind, the &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;ambient light&lt;/span&gt;&lt;/i&gt;&lt;span style="background-color: transparent;"&gt; &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;control&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; area simultaneously checks the ambient brightness. The state of the overall system thus consists of the states of its orthogonal regions. However, orthogonal ranges are not completely independent: when &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;ambient light control&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; changes from &lt;/span&gt;&lt;strong style="background-color: transparent;"&gt;Sensing&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; to &lt;/span&gt;&lt;strong style="background-color: transparent;"&gt;Waiting&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; the operator &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;raise&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; generates a &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;Sun.down&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; event to which the &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;main region&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; area reacts, and the blind should close. For this to happen, the transition &lt;/span&gt;&lt;strong style="background-color: transparent;"&gt;Idle → Moving down&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; requires the &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;Sun.down&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; event as another triggering event.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The simulation mode of YAKINDU Statechart Tools allows us to enter the ambient brightness value. If the value of &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Sun.brightness&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; is 80 or higher, the result looks like this:&lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung3.png?t=1510753614328&amp;amp;width=724&amp;amp;height=503&amp;amp;name=Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung3.png" alt="Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung3.png" width="724" height="503"&gt;
&lt;br&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The blinds should not only close depending on the ambient brightness, but also open. If we want to support independent wait times for both functions, we duplicate the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;ambient light control&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; area, adjust it for a brightness value, and extend the main region with a reaction &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Sun.up&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; in the same way as we did before:&lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung4.png?t=1510753614328&amp;amp;width=724&amp;amp;height=492&amp;amp;name=Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung4.png" alt="Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung4.png" width="724" height="492"&gt;
&lt;br&gt; 
&lt;p&gt;&amp;nbsp;&lt;/p&gt; 
&lt;div class="infobox"&gt; 
 &lt;p&gt;&lt;span style="font-weight: 400;"&gt;Orthogonal areas execute YAKINDU Statechart Tools sequentially within repetitive processing cycles. This is relevant when the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;raise&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; operator creates an event in area A that is to be processed in area B. However, each event only exists within the current processing cycle, so the execution of area A must occur before area B is reached. For more information on this, see "&lt;/span&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/user-guide/#raising-and-processing-an-event"&gt;&lt;span style="font-weight: 400;"&gt;Raising and processing an event&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;" in the YAKINDU Statechart Tools documentation.&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;h2&gt;&lt;strong&gt;Composite states&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Now consider the following scenario: on a cloudy day the sun is continually breaking through, then disappearing behind dense clouds. In this case the blind should not be moved up and down continuously, nor should it close in response to the first bright but short interval and then remain down for hours. It should restrict the sunlight only when it remains permanently bright outside, i.e. if the environmental brightness has not merely exceeded the threshold for a short time.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;This behaviour is modeled as shown in another figure. If the ambient brightness is below the threshold, the &lt;/span&gt;&lt;strong&gt;Not bright&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; state is active. If it exceeds the threshold value, the state machine changes to the &lt;/span&gt;&lt;strong&gt;Almost bright&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; state. Effectively this is saying “It is bright outside, but we are not sure if it will last long”. We should therefore wait a little longer before we close the blind. As long as we are in the&lt;/span&gt;&lt;strong&gt; Almost bright&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; state and the ambient brightness falls below the threshold, maybe because a cloud blocks the sun, the state machine immediately goes back to &lt;/span&gt;&lt;strong&gt;Not bright&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;, only to jump back to &lt;/span&gt;&lt;strong&gt;Almost bright&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; shortly afterwards. The transition leading to &lt;/span&gt;&lt;strong&gt;Waiting&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; is triggered and the blind is lowered only when &lt;/span&gt;&lt;strong&gt;Almost bright&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; is active for 10 minutes without interruption. This works because the period specified as the operand &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;after&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; is restarted each time the source state of the transition becomes active.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung5.png?t=1510753614328&amp;amp;width=713&amp;amp;height=627&amp;amp;name=Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung5.png" alt="Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung5.png" width="713" height="627"&gt;&lt;br&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The figure above also shows an extremely useful way to keep state diagrams manageable and structured: the composite state. The more states and transitions an state machine contains, the less clear the graphical representation becomes, when it should actually provide clarity. It becomes difficult to keep a view of the whole machine and to recognize structures and logical connections. In the extreme, in state diagrams with hundreds or thousands of states, this becomes completely impossible.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Composite states put structure and modularization into the diagram. A composite state contains inner states and state transitions and can thus encapsulate functionality. In the example of the blind control system the functionality of delayed darkening is in the combined state &lt;/span&gt;&lt;strong&gt;Sensing&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. A transition can lead to a compound state as such, but also directly to one of its inner states. The transition &lt;/span&gt;&lt;strong&gt;Waiting → Sensing&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; shows an example of the former. Leaving a composite state can be done by transitioning from an internal state to a state outside the composite state, for example &lt;/span&gt;&lt;strong&gt;Almost bright → Waiting&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. But a composite state as such can serve as the starting point of a transition. Such a transition is then triggered when the execution of the composite state reaches a final state or an exit node.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The composite state &lt;/span&gt;&lt;strong&gt;Sensing&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; has only a single range. However, composite states may well comprise several orthogonal regions, as we have already seen in the top level of the model.&lt;/span&gt;&lt;/p&gt; 
&lt;br&gt; 
&lt;div class="infobox"&gt; 
 &lt;p&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Statechart Tools allow the user to simplify the presentation further by hiding the interiors of a composite state in a subdiagram, as shown in the figure below.&lt;/span&gt;&lt;/p&gt; 
 &lt;img src="https://blogs.itemis.com/hs-fs/hubfs/Blog/YAKINDU%20Statechart%20Tools/Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung_6.png?t=1510753614328&amp;amp;width=440&amp;amp;height=377&amp;amp;name=Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung_6.png" alt="Modellieren_mit_Zustandsautomaten_Teil_2_Abbildung_6.png" width="440" height="377" style="display: block; margin-left: auto; margin-right: auto;"&gt;
 &lt;br&gt;
 &lt;br&gt; 
 &lt;p&gt;&lt;strong&gt;Sensing&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; now looks almost like a "normal" state: only the small symbol at the bottom right of the state indicates that it is a composite state. This type of representation saves a lot of space. The chapter "&lt;/span&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/user-guide/#using-subdiagrams"&gt;&lt;span style="font-weight: 400;"&gt;Using subdiagrams&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;" in the YAKINDU Statechart Tools documentation discusses this further.&lt;/span&gt;&lt;/p&gt; 
 &lt;p&gt;&lt;span style="font-weight: 400;"&gt;The graphical modeling language of YAKINDU Statechart Tools allows you to enter composite states via any number of named entry points (entries) and exit via any number of named exit points (exits). For the sake of clarity and intelligibility the number of these entry and exit points, as well as the number of transitions in and out, should be kept as small as possible.&lt;/span&gt;&lt;/p&gt; 
&lt;/div&gt; 
&lt;h2&gt;&lt;strong&gt;Further possibilities for improving the model&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The response of the blind control system to changes in ambient brightness can be further improved. Instead of every automatic opening or closing waiting for an extended period regardless of whether someone wants to change the blind’s position, it would be more flexible and comfortable to only let the automatic operation wait for a specific time if the user actually presses the [↑ ] or [↓] button.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In this context we might also consider combining the two orthogonal areas &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;ambient light control 1&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; and &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;ambient light control&lt;/span&gt;&lt;/i&gt; &lt;i&gt;&lt;span style="font-weight: 400;"&gt;2&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; into a single area and simplifying the working of the machine. This is left to the reader as an exercise.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In the third part of this series, I will show how state machines can be translated into other representations, for example into source code of a programming language. We will – at least in principle – see how to integrate the source code generated by YAKINDU Statechart Tools into an environment to sample real light sensors and to drive real motors.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;&lt;span style="font-weight: 400;"&gt;To read the whole “How to use state machines for your modeling” series, download our whitepaper for free.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=11a95e87-0e67-4562-beaa-35526a9e7616&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Download free whitepaper now" src="https://no-cache.hubspot.com/cta/default/761475/11a95e87-0e67-4562-beaa-35526a9e7616.png" align="middle"&gt;&lt;/a&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fhow-to-use-state-machines-for-your-modelling-part-2-time-controlled-triggering-of-state-transitions&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Wed, 16 Aug 2017 07:23:12 GMT</pubDate>
      <author>rainer.klute@itemis.de (Rainer Klute)</author>
      <guid>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modelling-part-2-time-controlled-triggering-of-state-transitions</guid>
      <dc:date>2017-08-16T07:23:12Z</dc:date>
    </item>
    <item>
      <title>How to use state machines for your modeling (Part 1)</title>
      <link>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modelling-part-1</link>
      <description>&lt;div class="hs-featured-image-wrapper"&gt; 
 &lt;a href="https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modelling-part-1" title="" class="hs-featured-image-link"&gt; &lt;img src="https://blogs.itemis.com/hubfs/Blog/YAKINDU%20Statechart%20Tools/ha%CC%88nde-tippen-am-computer.jpg?t=1510753614328" alt="How to use state machines for your modeling (Part 1)" class="hs-featured-image" style="width:auto !important; max-width:50%; float:left; margin:0 15px 15px 0;"&gt; &lt;/a&gt; 
&lt;/div&gt;    
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;Computer science is about solving specific tasks with the help of computers or computer-controlled systems. Examples might include the creation of a railway timetable, the visualisation of neutron fluxes, the distribution of power in a nuclear reactor, the simulation of physical processes in semiconductor components, the implementation of a social media app or the development of machine control systems of various types.&lt;/span&gt;&lt;/p&gt;</description>
      <content:encoded>&lt;p&gt;&lt;span style="background-color: transparent;"&gt;Computer science is about solving specific tasks with the help of computers or computer-controlled systems. Examples might include the creation of a railway timetable, the visualisation of neutron fluxes, the distribution of power in a nuclear reactor, the simulation of physical processes in semiconductor components, the implementation of a social media app or the development of machine control systems of various types.&lt;/span&gt;&lt;/p&gt;  
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;A model of what is to be implemented in software should be available before programming begins. A model is a simplified representation of reality, and excludes everything that is irrelevant to the task to be solved. In a control system for a coffee machine, for example, the fill level of the beans is important, while the colour of the coffee cup or the gender of the operator is not.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The model should be clear and easy to understand, and through sensible structuring even complex interrelationships can be managed. Comprehensible models are important, not only for software architects and developers, but also for their clients, i.e. departments and customers. If a model is comprehensible, the client can use it to determine whether the developers have understood the task correctly. Mistakes and misunderstandings can be clarified before any effort is wasted in implementing an incorrect solution.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Some tasks can be described particularly well with the aid of state machines. Computer science students may learn state automatons as deterministic automata, &lt;/span&gt;&lt;a href="https://en.wikipedia.org/wiki/Finite-state_machine"&gt;&lt;span style="font-weight: 400;"&gt;finite state machines&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;, Moore, Mealy, Harel automata or the like in theoretical computer science – but not infrequently question marks remain on their faces, as if to say “What is that supposed to be?”&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Automatic state machines: no mere theory&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Automatic state machines are suitable for describing so-called “event-discrete systems”. The idea here is that a system is always in exactly one of a finite number of states. For example, a light switch is always in one of two states, "On" or "Off". State transitions define from which states other states can be reached and under what conditions each state transition occurs.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Before this discussion becomes theoretical, let's look at a concrete example: a control system for a blind. In the simplest case, this has three states:&lt;/span&gt;&lt;/p&gt; 
&lt;ul&gt; 
 &lt;li&gt;&lt;span style="font-weight: 400;"&gt;The blind is not moving (state &lt;/span&gt;&lt;strong&gt;idle&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;).&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="font-weight: 400;"&gt;The blind is moving upwards (state &lt;/span&gt;&lt;strong&gt;Moving up&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;).&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span style="font-weight: 400;"&gt;The blind is moving downwards (state &lt;/span&gt;&lt;strong&gt;Moving down&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;).&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In the state diagram, states are represented as rectangles with rounded corners, and state transitions as arrows, as shown in Figure 1:&lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/yakindu/statechart-tools/Blogs/Modellieren_Zustandsautomaten/02_sketch_w1000.jpg?t=1510753614328&amp;amp;width=724&amp;amp;height=543&amp;amp;name=02_sketch_w1000.jpg" alt="02_sketch_w1000.jpg" width="724" height="543"&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The point on the left indicates the initial state of the machine, &lt;/span&gt;&lt;strong&gt;Idle&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. If the user presses the [↑] key, the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;up&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; event is created, the automaton changes to the state &lt;/span&gt;&lt;strong&gt;Moving up&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;, and the blind moves upwards. As soon as it reaches the upper position, the position sensor generates the event &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;upperPosition&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. This creates the transition state, the transition from &lt;/span&gt;&lt;strong&gt;Moving up&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; to &lt;/span&gt;&lt;strong&gt;Idle&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. Closing the blind works analogously when the user presses the [↓] button. The state diagram illustrates the dynamic behaviour of the system.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The model, however, is still imperfect. We want to be able to position blinds not only fully open or fully closed, but also at intermediate positions. In addition, the blind should automatically close when there is strong sunlight, and it also ought to be possible to control the blind manually. In addition the blind should always be raised in strong wind to avoid damage. Users should not be able to override this feature: it should not be possible to lower the blind until the wind has decreased. It may also be required to raise and lower the blinds at specific times.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Modeling state machines using the blind control as an example&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;We want to model some of these functions with the help of an automatic state machine rather than a pencil and a whiteboard, so we need a capable modeling tool. In the following example we used &lt;/span&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/"&gt;&lt;span style="font-weight: 400;"&gt;YAKINDU Statechart Tools&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;. This is Eclipse-based and supports, not only the modeling itself, but also dynamic simulation of the model and generation of the state machine as source code in various programming languages. This is discussed later.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;First we will convert the whiteboard model step by step using YAKINDU Statechart Tools. If you want to try this for yourself, you can download the software, an &lt;/span&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/installation/"&gt;&lt;span style="font-weight: 400;"&gt;installation guide&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt; and a &lt;/span&gt;&lt;a href="https://www.itemis.com/en/yakindu/state-machine/documentation/tutorials/#oss_five-minutes-tutorial"&gt;&lt;span style="font-weight: 400;"&gt;five-minute tutorial&lt;/span&gt;&lt;/a&gt;&lt;span style="font-weight: 400;"&gt;].&lt;/span&gt;&lt;/p&gt; 
&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=500b40d9-c019-4614-9236-be11d870e17e&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="&amp;nbsp; Download YAKINDU Statechart Tools" src="https://no-cache.hubspot.com/cta/default/761475/500b40d9-c019-4614-9236-be11d870e17e.png" align="middle"&gt;&lt;/a&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Modeled with this tool our blind control example looks like this:&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/yakindu/statechart-tools/Blogs/Modellieren_Zustandsautomaten/vbc_01.png?t=1510753614328&amp;amp;width=652&amp;amp;height=426&amp;amp;name=vbc_01.png" alt="vbc_01.png" width="652" height="426" style="display: block; margin-left: auto; margin-right: auto;"&gt;&lt;/span&gt;&lt;/p&gt; 
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The definition area, which defines the names of events, has been added.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;To stop the blind on the way up or down at the current position, the user presses the button that is opposite to the respective movement, for example, [↓] when the blind is moving up.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The corresponding extended model looks like this:&lt;/span&gt;&lt;/p&gt; 
&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/yakindu/statechart-tools/Blogs/Modellieren_Zustandsautomaten/vbc_02.png?t=1510753614328&amp;amp;width=651&amp;amp;height=426&amp;amp;name=vbc_02.png" alt="vbc_02.png" width="651" height="426" style="display: block; margin-left: auto; margin-right: auto;"&gt;
&lt;br&gt;
&lt;br&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;There are now two possible events instead of one, which lead from of the states of movement into the rest state. Commas next to the transitions separate their names.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;At the same time we have made a clear distinction between events that are triggered by the user and those by the position sensor of the blind. YAKINDU Statechart Tools refers to these as &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;interfaces&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;. The definition area determines which interfaces exist and which events are assigned to them. In our case this is the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;user&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; interface with the events &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;up&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; and &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;down&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, as well as the interface &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;PosSensor&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; with the events &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;upperPosition&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; and &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;lowerPosition&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;.&lt;/span&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;strong&gt;Conditional state transitions with variables and guard conditions&lt;/strong&gt;&lt;/h2&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;Let’s now introduce prevention of storm damage to the blind. For this purpose the blind has a wind speed sensor that provides values between 0 (no wind) and 100 (the maximum value of the sensor).&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;In the state machine the wind speed is available in the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;windspeed&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; variable of the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Wind&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; interface. To keep the example simple we will not go into how the wind speed is transferred to the variable. The &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;Wind&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; interface also contains the constant &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;STRONG&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt;, which indicates the speed at which the wind is strong enough for the blind to be raised.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;There is now an additional transition (the blue arrow) from the state &lt;/span&gt;&lt;strong&gt;Moving down&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; to the state &lt;/span&gt;&lt;strong&gt;Idle&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;. This is provided with a condition, "Wind.windspeed &amp;gt;= Wind.STRONG". This &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;guard condition&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; is enclosed in square brackets, and ensures that the transition is executed only if the condition is met. A further transition leads from &lt;/span&gt;&lt;strong&gt;Idle&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; to the state &lt;/span&gt;&lt;strong&gt;Moving up&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;, but only if the blind – as determined by the position sensor – is not already up. To make this information available the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;PosSensor&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; interface is extended accordingly.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;img src="https://blogs.itemis.com/hs-fs/hubfs/yakindu/statechart-tools/Blogs/Modellieren_Zustandsautomaten/vbc_03.png?t=1510753614328&amp;amp;width=724&amp;amp;height=311&amp;amp;name=vbc_03.png" alt="vbc_03.png" width="724" height="311"&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;The "blue" transitions in the state diagram thus ensure automatic raising of the blind. Now we just have to prevent the user from moving the blind down again. On the transition &lt;/span&gt;&lt;strong style="background-color: transparent;"&gt;Idle → Moving down&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; the guard condition "Wind.windspeed &amp;lt; Wind.STRONG" assigned to the &lt;/span&gt;&lt;i style="background-color: transparent;"&gt;&lt;span&gt;User.down&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; event ensures this.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;For the transition &lt;/span&gt;&lt;strong&gt;Moving up → Idle&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt;, however, this is not quite so simple, as it should be executed at the &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;PosSensor.upperPosition&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; event in any case. However, the guard condition always refers to all the events mentioned, so would not be useful here. The correct solution is to split the transition into two individual transitions: one transition takes care of the event &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;User.down&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; and contains the guard, the other takes &lt;/span&gt;&lt;i&gt;&lt;span style="font-weight: 400;"&gt;PosSensor.upperPosition&lt;/span&gt;&lt;/i&gt;&lt;span style="font-weight: 400;"&gt; without any additional condition to the &lt;/span&gt;&lt;strong&gt;Idle&lt;/strong&gt;&lt;span style="font-weight: 400;"&gt; state.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;We could now introduce a light sensor and, as described above, with its help automatically move the blinds down when it is very bright outside. This is, however, more tricky than in the case of strong wind, because the user can override that and move the blind up again. In this case, the automatic has to hold back and not shut down the blind again – at least not immediately. I will discuss this topic in another blog post, as well as interactive state machine simulation and the generation of Java, C or C++ source code. This saves us not only from manual programming, but also from the errors that are typical incurred.&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="font-weight: 400;"&gt;To read the whole “How to use state machines for your modeling” series, download our whitepaper for free.&lt;/span&gt;&lt;span style="background-color: transparent;"&gt;&amp;nbsp;&lt;/span&gt;&lt;/p&gt; 
&lt;p&gt;&lt;span style="background-color: transparent;"&gt;&lt;a class="cta_button" href="https://info.itemis.com/cs/ci/?pg=11a95e87-0e67-4562-beaa-35526a9e7616&amp;amp;pid=761475&amp;amp;ecid=&amp;amp;hseid=&amp;amp;hsic="&gt;&lt;img class="hs-cta-img " style="border-width: 0px; /*hs-extra-styles*/; margin: 0 auto; display: block; margin-top: 20px; margin-bottom: 20px" alt="Download free whitepaper now" src="https://no-cache.hubspot.com/cta/default/761475/11a95e87-0e67-4562-beaa-35526a9e7616.png" align="middle"&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;  
&lt;img src="http://track.hubspot.com/__ptq.gif?a=761475&amp;amp;k=14&amp;amp;r=https%3A%2F%2Fblogs.itemis.com%2Fen%2Fhow-to-use-state-machines-for-your-modelling-part-1&amp;amp;bu=https%253A%252F%252Fblogs.itemis.com&amp;amp;bvt=rss" alt="" width="1" height="1" style="min-height:1px!important;width:1px!important;border-width:0!important;margin-top:0!important;margin-bottom:0!important;margin-right:0!important;margin-left:0!important;padding-top:0!important;padding-bottom:0!important;padding-right:0!important;padding-left:0!important; "&gt;</content:encoded>
      <category>YAKINDU</category>
      <category>Statecharts</category>
      <category>Embedded</category>
      <category>State Machine</category>
      <pubDate>Wed, 09 Aug 2017 12:06:00 GMT</pubDate>
      <author>rainer.klute@itemis.de (Rainer Klute)</author>
      <guid>https://blogs.itemis.com/en/how-to-use-state-machines-for-your-modelling-part-1</guid>
      <dc:date>2017-08-09T12:06:00Z</dc:date>
    </item>
  </channel>
</rss>
